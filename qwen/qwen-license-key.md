# å¾ˆå¤šå…±äº«è½¯ä»¶éƒ½é€šè¿‡æ³¨å†Œç ä¹‹ç±»çš„æœºåˆ¶å¯¹è½¯ä»¶çš„ä½¿ç”¨æƒè¿›è¡Œä¿æŠ¤ï¼Œè¯·è§£é‡Šä¸€ä¸‹å®ƒçš„å·¥ä½œåŸç†

å…±äº«è½¯ä»¶ï¼ˆSharewareï¼‰æ˜¯ä¸€ç§â€œå…ˆè¯•ç”¨ã€åè´­ä¹°â€çš„è½¯ä»¶åˆ†å‘æ¨¡å¼ï¼Œç”¨æˆ·å¯ä»¥å…è´¹ä¸‹è½½å¹¶ä½¿ç”¨è½¯ä»¶çš„éƒ¨åˆ†åŠŸèƒ½æˆ–åœ¨é™å®šæ—¶é—´å†…å®Œæ•´ä½¿ç”¨ï¼Œä¹‹åé€šè¿‡æ”¯ä»˜è´¹ç”¨è·å–æ­£å¼æˆæƒï¼Œä»¥è§£é™¤é™åˆ¶æˆ–è·å¾—å®Œæ•´åŠŸèƒ½ã€‚ä¸ºäº†ä¿æŠ¤è½¯ä»¶çš„ç‰ˆæƒå’Œå®ç°å•†ä¸šåŒ–ï¼Œå¼€å‘è€…é€šå¸¸ä¼šä½¿ç”¨**æ³¨å†Œç æœºåˆ¶**ï¼ˆRegistration Key / License Keyï¼‰æ¥æ§åˆ¶è½¯ä»¶çš„ä½¿ç”¨æƒã€‚ä¸‹é¢æ˜¯æ³¨å†Œç æœºåˆ¶çš„å·¥ä½œåŸç†ï¼š

---

### ä¸€ã€æ³¨å†Œç æœºåˆ¶çš„åŸºæœ¬æµç¨‹

1. **è¯•ç”¨é˜¶æ®µï¼ˆæœªæ³¨å†Œï¼‰**
   - ç”¨æˆ·ä¸‹è½½å¹¶å®‰è£…å…±äº«è½¯ä»¶ã€‚
   - è½¯ä»¶åœ¨æœªæ³¨å†ŒçŠ¶æ€ä¸‹è¿è¡Œï¼Œå¯èƒ½æœ‰ä»¥ä¸‹é™åˆ¶ï¼š
     - åŠŸèƒ½å—é™ï¼ˆå¦‚æŸäº›é«˜çº§åŠŸèƒ½ç¦ç”¨ï¼‰
     - æ—¶é—´é™åˆ¶ï¼ˆå¦‚30å¤©è¯•ç”¨æœŸï¼‰
     - å¯åŠ¨æç¤ºï¼ˆé¢‘ç¹å¼¹å‡ºâ€œè¯·æ³¨å†Œâ€æç¤ºï¼‰
     - æ°´å°æˆ–å¯¼å‡ºé™åˆ¶

2. **è´­ä¹°ä¸æ³¨å†Œ**
   - ç”¨æˆ·å†³å®šè´­ä¹°ï¼Œå‘å¼€å‘è€…æˆ–é”€å”®å¹³å°æ”¯ä»˜è´¹ç”¨ã€‚
   - æ”¯ä»˜æˆåŠŸåï¼Œç³»ç»Ÿç”Ÿæˆä¸€ä¸ª**å”¯ä¸€çš„æ³¨å†Œç **ï¼ˆä¹Ÿå«åºåˆ—å·ã€æ¿€æ´»ç ï¼‰å‘é€ç»™ç”¨æˆ·ã€‚

3. **è¾“å…¥æ³¨å†Œç **
   - ç”¨æˆ·åœ¨è½¯ä»¶ä¸­è¾“å…¥æ³¨å†Œç ã€‚
   - è½¯ä»¶éªŒè¯è¯¥æ³¨å†Œç æ˜¯å¦æœ‰æ•ˆã€‚
   - éªŒè¯é€šè¿‡åï¼Œè½¯ä»¶è¿›å…¥â€œå·²æ³¨å†Œâ€çŠ¶æ€ï¼Œè§£é™¤é™åˆ¶ã€‚

---

### äºŒã€æ³¨å†Œç çš„å·¥ä½œåŸç†ï¼ˆæŠ€æœ¯å®ç°ï¼‰

æ³¨å†Œç æœºåˆ¶çš„æ ¸å¿ƒæ˜¯**éªŒè¯æœºåˆ¶**ï¼Œé€šå¸¸åŒ…æ‹¬ä»¥ä¸‹å‡ ç§æŠ€æœ¯æ‰‹æ®µï¼š

#### 1. **ç®€å•æ³¨å†Œç ï¼ˆåŸºäºå›ºå®šè§„åˆ™ï¼‰**
   - æ³¨å†Œç æ˜¯é¢„å…ˆç”Ÿæˆçš„å›ºå®šå­—ç¬¦ä¸²ï¼ˆå¦‚ `ABCDE-FGHIJ-KLMNO-PQRST`ï¼‰ã€‚
   - è½¯ä»¶å†…éƒ¨åŒ…å«ä¸€ä¸ªåˆæ³•æ³¨å†Œç åˆ—è¡¨æˆ–ç”Ÿæˆè§„åˆ™ã€‚
   - ç”¨æˆ·è¾“å…¥åï¼Œè½¯ä»¶æ£€æŸ¥æ˜¯å¦åŒ¹é…ã€‚
   - âŒ ç¼ºç‚¹ï¼šå®¹æ˜“è¢«ç ´è§£æˆ–æ³„éœ²ã€‚

#### 2. **ç®—æ³•éªŒè¯ï¼ˆæ³¨å†Œç ç”Ÿæˆä¸éªŒè¯ç®—æ³•ï¼‰**
   - å¼€å‘è€…è®¾è®¡ä¸€ä¸ª**æ•°å­¦ç®—æ³•**ï¼Œç”¨äºç”Ÿæˆå’ŒéªŒè¯æ³¨å†Œç ã€‚
   - ä¾‹å¦‚ï¼šæ ¹æ®ç”¨æˆ·ä¿¡æ¯ï¼ˆå¦‚ç”¨æˆ·åã€æœºå™¨ç ï¼‰ç”Ÿæˆæ³¨å†Œç ã€‚
   - è½¯ä»¶ä¸­åŒ…å«éªŒè¯ç®—æ³•ï¼Œä½†ä¸åŒ…å«ç”Ÿæˆç®—æ³•ï¼ˆæˆ–åå‘å›°éš¾ï¼‰ã€‚
   - ç¤ºä¾‹ï¼š
     ```
     è¾“å…¥ï¼šç”¨æˆ·å "Alice" + æœºå™¨ç  "1234ABCD"
     â†’ é€šè¿‡å“ˆå¸Œæˆ–åŠ å¯†ç®—æ³•ç”Ÿæˆæ³¨å†Œç ï¼šX9Z8-Y7W6-V5U4
     ```
   - è½¯ä»¶éªŒè¯æ—¶é‡æ–°è®¡ç®—ï¼Œçœ‹æ˜¯å¦åŒ¹é…ã€‚

#### 3. **å…¬é’¥åŠ å¯†ï¼ˆæ›´å®‰å…¨çš„æ–¹å¼ï¼‰**
   - ä½¿ç”¨éå¯¹ç§°åŠ å¯†ï¼ˆå¦‚RSAï¼‰ï¼š
     - å¼€å‘è€…ç”¨**ç§é’¥**ç”Ÿæˆæ³¨å†Œç ï¼ˆæ•°å­—ç­¾åï¼‰ã€‚
     - è½¯ä»¶ä¸­å†…ç½®**å…¬é’¥**ï¼Œç”¨äºéªŒè¯æ³¨å†Œç çš„åˆæ³•æ€§ã€‚
   - å³ä½¿é€†å‘å·¥ç¨‹çœ‹åˆ°å…¬é’¥ï¼Œä¹Ÿæ— æ³•ä¼ªé€ æœ‰æ•ˆæ³¨å†Œç ï¼ˆå› ä¸ºæ²¡æœ‰ç§é’¥ï¼‰ã€‚
   - è¿™æ˜¯æœ€å®‰å…¨çš„æ–¹å¼ä¹‹ä¸€ï¼Œå¸¸è§äºç°ä»£å•†ä¸šè½¯ä»¶ã€‚

#### 4. **ç»‘å®šç¡¬ä»¶ä¿¡æ¯ï¼ˆé˜²å…±äº«ï¼‰**
   - æ³¨å†Œç ä¸ç”¨æˆ·è®¾å¤‡çš„**ç¡¬ä»¶æŒ‡çº¹**ç»‘å®šï¼Œå¦‚ï¼š
     - ç¡¬ç›˜åºåˆ—å·
     - MACåœ°å€
     - CPU ID
     - ä¸»æ¿ä¿¡æ¯
   - æ³¨å†Œç åªèƒ½åœ¨ç‰¹å®šè®¾å¤‡ä¸Šä½¿ç”¨ï¼Œé˜²æ­¢ç”¨æˆ·å°†æ³¨å†Œç åˆ†äº«ç»™ä»–äººã€‚

#### 5. **åœ¨çº¿æ¿€æ´»ï¼ˆæœåŠ¡å™¨éªŒè¯ï¼‰**
   - ç”¨æˆ·è¾“å…¥æ³¨å†Œç åï¼Œè½¯ä»¶è¿æ¥å¼€å‘è€…æœåŠ¡å™¨è¿›è¡ŒéªŒè¯ã€‚
   - æœåŠ¡å™¨æ£€æŸ¥ï¼š
     - æ³¨å†Œç æ˜¯å¦æœ‰æ•ˆ
     - æ˜¯å¦å·²è¢«ä½¿ç”¨ï¼ˆé˜²é‡å¤æ¿€æ´»ï¼‰
     - æ˜¯å¦ç»‘å®šè®¾å¤‡
   - éªŒè¯é€šè¿‡åï¼Œè¿”å›æ¿€æ´»ç¡®è®¤ã€‚
   - ä¼˜ç‚¹ï¼šå¯å®ç°æˆæƒç®¡ç†ã€é™åˆ¶å®‰è£…æ¬¡æ•°ã€è¿œç¨‹åŠé”€ç­‰ã€‚

---

### ä¸‰ã€æ³¨å†Œç çš„å®‰å…¨æ€§æŒ‘æˆ˜

| é£é™© | è¯´æ˜ |
|------|------|
| **æ³¨å†Œæœºï¼ˆKeygenï¼‰** | é»‘å®¢é€†å‘è½¯ä»¶ï¼Œæ‰¾å‡ºæ³¨å†Œç ç”Ÿæˆç®—æ³•ï¼Œåˆ¶ä½œâ€œæ³¨å†Œæœºâ€ç”Ÿæˆéæ³•æ³¨å†Œç ã€‚ |
| **å†…å­˜è¡¥ä¸ï¼ˆCrackï¼‰** | ä¿®æ”¹è½¯ä»¶è¿è¡Œæ—¶çš„å†…å­˜ï¼Œè·³è¿‡éªŒè¯é€»è¾‘ï¼Œç›´æ¥è¿›å…¥æ³¨å†ŒçŠ¶æ€ã€‚ |
| **æ³¨å†Œç æ³„éœ²** | åˆæ³•æ³¨å†Œç è¢«å…¬å¼€ä¼ æ’­ï¼Œå¤šäººå…±ç”¨ã€‚ |
| **è™šæ‹Ÿæœº/å…‹éš†ç»•è¿‡** | é€šè¿‡å¤åˆ¶å·²æ¿€æ´»çš„è™šæ‹Ÿæœºç»•è¿‡ç»‘å®šã€‚ |

---

### å››ã€ç°ä»£æ”¹è¿›æ–¹æ¡ˆ

ä¸ºå¢å¼ºå®‰å…¨æ€§ï¼Œç°ä»£è½¯ä»¶å¸¸é‡‡ç”¨ç»„åˆç­–ç•¥ï¼š

- **åœ¨çº¿æ¿€æ´» + æœåŠ¡å™¨éªŒè¯**
- **ç¡¬ä»¶ç»‘å®š + äº‘æˆæƒç®¡ç†**
- **å®šæœŸè”ç½‘éªŒè¯**ï¼ˆå¦‚è®¢é˜…åˆ¶è½¯ä»¶ï¼‰
- **ä»£ç æ··æ·† + åè°ƒè¯•æŠ€æœ¯** é˜²æ­¢é€†å‘
- **ä½¿ç”¨è®¸å¯è¯æ–‡ä»¶ï¼ˆLicense Fileï¼‰** æ›¿ä»£çº¯æ³¨å†Œç ï¼ŒåŒ…å«æ›´å¤šå…ƒæ•°æ®ï¼ˆæœ‰æ•ˆæœŸã€åŠŸèƒ½æƒé™ç­‰ï¼‰

---

### æ€»ç»“

æ³¨å†Œç æœºåˆ¶çš„æœ¬è´¨æ˜¯**èº«ä»½ä¸æƒé™çš„éªŒè¯ç³»ç»Ÿ**ï¼Œé€šè¿‡å¯†ç å­¦ã€ç®—æ³•æˆ–ç½‘ç»œéªŒè¯ï¼Œç¡®ä¿åªæœ‰ä»˜è´¹ç”¨æˆ·æ‰èƒ½è·å¾—å®Œæ•´ä½¿ç”¨æƒã€‚è™½ç„¶æ— æ³•å®Œå…¨é˜²æ­¢ç ´è§£ï¼Œä½†èƒ½æœ‰æ•ˆæé«˜ç›—ç‰ˆé—¨æ§›ï¼Œä¿æŠ¤å¼€å‘è€…åˆ©ç›Šã€‚éšç€æŠ€æœ¯å‘å±•ï¼Œæ³¨å†Œç æ­£é€æ­¥æ¼”å˜ä¸ºæ›´å¤æ‚çš„**æ•°å­—è®¸å¯è¯ç®¡ç†ç³»ç»Ÿ**ï¼ˆLicense Management Systemï¼‰ã€‚


# ç”¨golangå®ç°ä¸€ä¸ªç®€å•æ³¨å†Œç çš„ç”Ÿæˆä¸éªŒè¯

ä¸‹é¢æ˜¯ä¸€ä¸ªä½¿ç”¨ **Goè¯­è¨€ï¼ˆGolangï¼‰** å®ç°çš„**ç®€å•æ³¨å†Œç ç”Ÿæˆä¸éªŒè¯ç³»ç»Ÿ**çš„ä¾‹å­ã€‚è¯¥ç³»ç»ŸåŸºäºä»¥ä¸‹è®¾è®¡ï¼š

---

### âœ… åŠŸèƒ½ç›®æ ‡

- æ ¹æ®ç”¨æˆ·åç”Ÿæˆæ³¨å†Œç 
- ä½¿ç”¨ **HMAC-SHA256** ç®—æ³• + **å¯†é’¥ï¼ˆsecret keyï¼‰** ä¿è¯å®‰å…¨æ€§
- æ³¨å†Œç æ ¼å¼ï¼š`XXXX-XXXX-XXXX-XXXX`ï¼ˆ16ä½åˆ†ç»„ï¼Œå…±4ç»„ï¼‰
- éªŒè¯æ—¶æ£€æŸ¥æ³¨å†Œç æ˜¯å¦åŒ¹é…ç”¨æˆ·å

> ğŸ” ä½¿ç”¨ HMAC å¯é˜²æ­¢é€†å‘æ¨å¯¼ï¼Œåªæœ‰çŸ¥é“å¯†é’¥æ‰èƒ½ç”Ÿæˆåˆæ³•æ³¨å†Œç ã€‚

---

### ğŸ“¦ å®Œæ•´ä»£ç ç¤ºä¾‹

```go
package main

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"strings"
)

// å…¨å±€å¯†é’¥ï¼ˆåº”ä¿å¯†ï¼Œä¸å¯æ³„éœ²ï¼‰
var secretKey = []byte("your-super-secret-license-key-2024")

// ç”Ÿæˆæ³¨å†Œç ï¼šåŸºäºç”¨æˆ·åç”Ÿæˆ HMAC-SHA256 å“ˆå¸Œï¼Œç¼–ç ä¸ºæ ¼å¼åŒ–å­—ç¬¦ä¸²
func generateLicense(username string) string {
	// ä½¿ç”¨ HMAC-SHA256 ç”Ÿæˆç­¾å
	h := hmac.New(sha256.New, secretKey)
	h.Write([]byte(username))
	signature := h.Sum(nil)

	// ä½¿ç”¨ base64 ç¼–ç ï¼ˆURL å®‰å…¨ï¼‰ï¼Œå¹¶æˆªå–å‰ 16 å­—èŠ‚ï¼ˆ128ä½ï¼‰
	encoded := base64.RawURLEncoding.EncodeToString(signature)[:16]

	// æ ¼å¼åŒ–ä¸º XXXX-XXXX-XXXX-XXXX
	var parts []string
	for i := 0; i < len(encoded); i += 4 {
		parts = append(parts, encoded[i:i+4])
	}
	return strings.Join(parts, "-")
}

// éªŒè¯æ³¨å†Œç ï¼šé‡æ–°è®¡ç®—å¹¶æ¯”å¯¹
func validateLicense(username, license string) bool {
	expected := generateLicense(username)
	return hmac.Equal([]byte(expected), []byte(license))
}

// ä¸»å‡½æ•°æµ‹è¯•
func main() {
	username := "Alice"

	// 1. ç”Ÿæˆæ³¨å†Œç 
	license := generateLicense(username)
	fmt.Printf("ç”¨æˆ·å: %s\n", username)
	fmt.Printf("æ³¨å†Œç : %s\n", license)

	// 2. éªŒè¯æ­£ç¡®çš„æ³¨å†Œç 
	isValid := validateLicense(username, license)
	fmt.Printf("éªŒè¯ç»“æœ: %v\n", isValid) // true

	// 3. éªŒè¯é”™è¯¯çš„æ³¨å†Œç 
	invalidLicense := "ABCD-EFGH-1234-5678"
	isValid = validateLicense(username, invalidLicense)
	fmt.Printf("é”™è¯¯æ³¨å†Œç éªŒè¯: %v\n", isValid) // false

	// 4. éªŒè¯é”™è¯¯ç”¨æˆ·å
	isValid = validateLicense("Bob", license)
	fmt.Printf("Bob ä½¿ç”¨ Alice çš„æ³¨å†Œç : %v\n", isValid) // false
}
```

---

### ğŸ” è¾“å‡ºç¤ºä¾‹

```text
ç”¨æˆ·å: Alice
æ³¨å†Œç : 7c6d-8f3a-9e2b-c1d4
éªŒè¯ç»“æœ: true
é”™è¯¯æ³¨å†Œç éªŒè¯: false
Bob ä½¿ç”¨ Alice çš„æ³¨å†Œç : false
```

---

### ğŸ” å®‰å…¨è¯´æ˜

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **é˜²ä¼ªé€ ** | æ²¡æœ‰ `secretKey` æ— æ³•ç”Ÿæˆåˆæ³•æ³¨å†Œç  |
| **ç”¨æˆ·åç»‘å®š** | æ¯ä¸ªç”¨æˆ·åçš„æ³¨å†Œç ä¸åŒ |
| **HMAC å®‰å…¨æ€§** | å³ä½¿çŸ¥é“ç®—æ³•ï¼Œä¹Ÿæ— æ³•é€†å‘ç”Ÿæˆæœ‰æ•ˆç  |
| **ä¸å¯é€†** | æ— æ³•ä»æ³¨å†Œç åæ¨å‡ºç”¨æˆ·åæˆ–å¯†é’¥ |

---

### âš ï¸ æ³¨æ„äº‹é¡¹

1. **å¯†é’¥ä¿å¯†**ï¼š`secretKey` å¿…é¡»åœ¨æœåŠ¡ç«¯ä¿å­˜ï¼Œ**ä¸èƒ½ç¡¬ç¼–ç åœ¨å®¢æˆ·ç«¯è½¯ä»¶ä¸­**ï¼ˆå¦åˆ™å¯è¢«åç¼–è¯‘æå–ï¼‰ã€‚
2. **ç”Ÿäº§ç¯å¢ƒå»ºè®®**ï¼š
   - ä½¿ç”¨**æœåŠ¡å™¨ç«¯ç”Ÿæˆæ³¨å†Œç **
   - å®¢æˆ·ç«¯åªåšéªŒè¯ï¼ˆæˆ–å®Œå…¨åœ¨çº¿éªŒè¯ï¼‰
   - å¯åŠ å…¥æ—¶é—´ã€ç¡¬ä»¶ç ç­‰ä¿¡æ¯å¢å¼ºç»‘å®š
3. **é˜²ç ´è§£**ï¼šæ­¤æ–¹æ¡ˆå¯é˜²æ™®é€šç”¨æˆ·ç›—ç”¨ï¼Œä½†æ— æ³•é˜²æ­¢é«˜çº§é€†å‘ï¼ˆå¦‚å†…å­˜è¡¥ä¸ï¼‰ã€‚å¦‚éœ€æ›´å¼ºä¿æŠ¤ï¼Œåº”ç»“åˆæ··æ·†ã€åè°ƒè¯•ã€åœ¨çº¿æ¿€æ´»ç­‰ã€‚

---

### âœ… æ‰©å±•å»ºè®®

ä½ å¯ä»¥è¿›ä¸€æ­¥æ”¹è¿›ï¼š

- åŠ å…¥ **æœºå™¨ç ç»‘å®š**ï¼ˆå¦‚ç¡¬ç›˜åºåˆ—å·ï¼‰
- æ”¯æŒ **æœ‰æ•ˆæœŸ**ï¼ˆåœ¨æ•°æ®ä¸­åŠ å…¥æ—¶é—´æˆ³ï¼Œç”¨ AES åŠ å¯†æ‰“åŒ…ï¼‰
- ä½¿ç”¨ **è®¸å¯è¯æ–‡ä»¶ï¼ˆJSON + ç­¾åï¼‰** æ›¿ä»£çº¯æ³¨å†Œç 
- æä¾› **åœ¨çº¿æ¿€æ´»æ¥å£**

---

### ğŸ§© ç¤ºä¾‹ï¼šç”Ÿæˆå¸¦æ—¶é—´é™åˆ¶çš„æ³¨å†Œç ï¼ˆè¿›é˜¶æ€è·¯ï¼‰

```go
type LicenseData struct {
	Username string
	Expiry   int64 // Unix æ—¶é—´æˆ³
}

// å°†ç»“æ„ä½“åºåˆ—åŒ– + HMAC ç­¾åï¼Œç”Ÿæˆå®‰å…¨ä»¤ç‰Œ
```

ä½ å¯ä»¥ä½¿ç”¨ JWT æˆ–è‡ªå®šä¹‰æ ¼å¼å®ç°æ›´å¤æ‚çš„æˆæƒé€»è¾‘ã€‚

---

å¦‚æœä½ å¸Œæœ›æˆ‘è¿›ä¸€æ­¥å®ç°**å¸¦è¿‡æœŸæ—¶é—´**æˆ–**ç¡¬ä»¶ç»‘å®š**çš„ç‰ˆæœ¬ï¼Œä¹Ÿå¯ä»¥ç»§ç»­å‘Šè¯‰æˆ‘ï¼

# å®ç°å¸¦è¿‡æœŸæ—¶é—´æˆ–ç¡¬ä»¶ç»‘å®šçš„ç‰ˆæœ¬

ä¸‹é¢æ˜¯ä¸€ä¸ªä½¿ç”¨ **Go è¯­è¨€**å®ç°çš„**å¢å¼ºç‰ˆæ³¨å†Œç ç³»ç»Ÿ**ï¼Œæ”¯æŒï¼š

âœ… **ç”¨æˆ·åç»‘å®š**  
âœ… **è¿‡æœŸæ—¶é—´æ§åˆ¶**ï¼ˆå¦‚30å¤©è¯•ç”¨ï¼‰  
âœ… **ç¡¬ä»¶æŒ‡çº¹ç»‘å®š**ï¼ˆå¦‚æœºå™¨MACåœ°å€ï¼‰  
âœ… ä½¿ç”¨ **HMAC-SHA256 ç­¾å** é˜²ä¼ªé€   
âœ… æ³¨å†Œç ä¸º **Base64 ç¼–ç çš„ç»“æ„åŒ–æ•°æ®**

---

## ğŸ§© åŠŸèƒ½è®¾è®¡

æ³¨å†Œç å°†åŒ…å«ä»¥ä¸‹ä¿¡æ¯ï¼ˆç¼–ç åï¼‰ï¼š
```json
{
  "user": "Alice",
  "expires": 1735689600,  // Unix æ—¶é—´æˆ³ï¼ˆ2025-01-01ï¼‰
  "hwid": "a1b2c3d4"     // ç¡¬ä»¶æŒ‡çº¹ï¼ˆå¦‚ MAC åœ°å€å“ˆå¸Œï¼‰
}
```

ç„¶åè¿›è¡Œï¼š
1. **åºåˆ—åŒ– â†’ JSON**
2. **HMAC ç­¾å**ï¼ˆé˜²ç¯¡æ”¹ï¼‰
3. **Base64 ç¼–ç ** ç”Ÿæˆæœ€ç»ˆæ³¨å†Œç 

éªŒè¯æ—¶åå‘è§£æå¹¶æ ¡éªŒç­¾åã€æ—¶é—´ã€ç¡¬ä»¶IDã€‚

---

## âœ… å®Œæ•´ Go å®ç°

```go
package main

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
	"time"
)

// å…¨å±€å¯†é’¥ï¼ˆå¿…é¡»ä¿å¯†ï¼æœåŠ¡ç«¯ä¸“ç”¨ï¼‰
var secretKey = []byte("your-super-secret-license-key-2024")

// ç¡¬ä»¶IDè·å–ï¼ˆç¤ºä¾‹ï¼šå®é™…é¡¹ç›®ä¸­å¯è¯»å– MACã€ç¡¬ç›˜åºåˆ—å·ç­‰ï¼‰
func getHardwareID() string {
	// ç¤ºä¾‹ï¼šå®é™…ä¸­å¯ä»ç½‘ç»œæ¥å£è·å– MAC å¹¶å“ˆå¸Œ
	return "a1b2c3d4" // æ¨¡æ‹Ÿç¡¬ä»¶ID
}

// LicenseData æ³¨å†Œç æ•°æ®ç»“æ„
type LicenseData struct {
	User    string `json:"user"`
	Expires int64  `json:"expires"` // Unix æ—¶é—´æˆ³ï¼ˆç§’ï¼‰
	HWID    string `json:"hwid"`    // ç¡¬ä»¶æŒ‡çº¹
}

// ç”Ÿæˆæ³¨å†Œç ï¼šuser + è¿‡æœŸæ—¶é—´ï¼ˆå¤©ï¼‰ + å½“å‰æœºå™¨hwid
func generateLicense(username string, days int) string {
	expires := time.Now().AddDate(0, 0, days).Unix()

	data := LicenseData{
		User:    username,
		Expires: expires,
		HWID:    getHardwareID(),
	}

	// åºåˆ—åŒ–ä¸º JSON
	jsonData, err := json.Marshal(data)
	if err != nil {
		panic(err)
	}

	// è®¡ç®— HMAC ç­¾å
	mac := hmac.New(sha256.New, secretKey)
	mac.Write(jsonData)
	signature := mac.Sum(nil)

	// æ‹¼æ¥ï¼šdata.signature
	encodedData := base64.RawURLEncoding.EncodeToString(jsonData)
	encodedSig := base64.RawURLEncoding.EncodeToString(signature)
	license := encodedData + "." + encodedSig

	// æ ¼å¼åŒ–ï¼šæ¯4ä½åˆ†ç»„ï¼Œç”¨ - è¿æ¥ï¼ˆå¯é€‰ï¼‰
	formatted := formatKey(license)
	return formatted
}

// éªŒè¯æ³¨å†Œç ï¼ˆéœ€ä¼ å…¥å½“å‰ç”¨æˆ·åå’Œç¡¬ä»¶IDï¼‰
func validateLicense(username, license string) (bool, string) {
	// å»æ ¼å¼åŒ–
	license = strings.ReplaceAll(license, "-", "")

	parts := strings.Split(license, ".")
	if len(parts) != 2 {
		return false, "æ— æ•ˆçš„æ³¨å†Œç æ ¼å¼"
	}

	// è§£ç  data å’Œ signature
	dataBytes, err := base64.RawURLEncoding.DecodeString(parts[0])
	if err != nil {
		return false, "è§£ç å¤±è´¥ï¼šæ•°æ®éƒ¨åˆ†"
	}
	sigBytes, err := base64.RawURLEncoding.DecodeString(parts[1])
	if err != nil {
		return false, "è§£ç å¤±è´¥ï¼šç­¾åéƒ¨åˆ†"
	}

	// éªŒè¯ HMAC ç­¾å
	mac := hmac.New(sha256.New, secretKey)
	mac.Write(dataBytes)
	expectedSig := mac.Sum(nil)

	if !hmac.Equal(sigBytes, expectedSig) {
		return false, "ç­¾åéªŒè¯å¤±è´¥ï¼ˆå¯†é’¥ä¸åŒ¹é…æˆ–è¢«ç¯¡æ”¹ï¼‰"
	}

	// è§£ææ•°æ®
	var data LicenseData
	if err := json.Unmarshal(dataBytes, &data); err != nil {
		return false, "è§£ææ•°æ®å¤±è´¥"
	}

	// æ£€æŸ¥ç”¨æˆ·å
	if data.User != username {
		return false, "ç”¨æˆ·åä¸åŒ¹é…"
	}

	// æ£€æŸ¥ç¡¬ä»¶ID
	if data.HWID != getHardwareID() {
		return false, "ç¡¬ä»¶ä¸åŒ¹é…ï¼ˆéæˆæƒè®¾å¤‡ï¼‰"
	}

	// æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
	if time.Now().Unix() > data.Expires {
		return false, "æ³¨å†Œç å·²è¿‡æœŸ"
	}

	return true, "éªŒè¯æˆåŠŸ"
}

// æ ¼å¼åŒ–æ³¨å†Œç ï¼šæ¯4å­—ç¬¦ä¸€ç»„ï¼Œå…±5ç»„ï¼Œç”¨ - åˆ†éš”ï¼ˆä¾¿äºè¾“å…¥ï¼‰
func formatKey(s string) string {
	var result strings.Builder
	for i, char := range s {
		result.WriteRune(char)
		if (i+1)%4 == 0 && i != len(s)-1 {
			result.WriteRune('-')
		}
	}
	return result.String()
}

// ä¸»å‡½æ•°æµ‹è¯•
func main() {
	username := "Alice"

	// 1. ç”Ÿæˆä¸€ä¸ª30å¤©æœ‰æ•ˆçš„æ³¨å†Œç 
	license := generateLicense(username, 30)
	fmt.Printf("ç”¨æˆ·å: %s\n", username)
	fmt.Printf("ç¡¬ä»¶ID: %s\n", getHardwareID())
	fmt.Printf("æ³¨å†Œç :\n%s\n\n", license)

	// 2. æ­£ç¡®éªŒè¯
	valid, msg := validateLicense(username, license)
	fmt.Printf("âœ… éªŒè¯ç»“æœ: %v | ä¿¡æ¯: %s\n", valid, msg)

	// 3. é”™è¯¯ç”¨æˆ·å
	valid, msg = validateLicense("Bob", license)
	fmt.Printf("âŒ Bob éªŒè¯: %v | ä¿¡æ¯: %s\n", valid, msg)

	// 4. æ¨¡æ‹Ÿä¸åŒè®¾å¤‡ï¼ˆä¿®æ”¹ç¡¬ä»¶IDï¼‰
	originalHWID := getHardwareID()
	// æ¨¡æ‹Ÿæ›¿æ¢ getHardwareID
	getHardwareID = func() string { return "fake-hwid-9999" }
	valid, msg = validateLicense(username, license)
	fmt.Printf("âŒ ä¸åŒè®¾å¤‡éªŒè¯: %v | ä¿¡æ¯: %s\n", valid, msg)

	// æ¢å¤
	getHardwareID = func() string { return originalHWID }

	// 5. æµ‹è¯•è¿‡æœŸï¼ˆä¿®æ”¹æ—¶é—´ï¼‰
	// æˆ‘ä»¬å¯ä»¥ä¼ªé€ ä¸€ä¸ªè¿‡æœŸçš„æ³¨å†Œç æ¥æµ‹è¯•
	expiredData := LicenseData{
		User:    "Alice",
		Expires: time.Now().Add(-24 * time.Hour).Unix(), // æ˜¨å¤©
		HWID:    getHardwareID(),
	}
	expiredJSON, _ := json.Marshal(expiredData)
	mac := hmac.New(sha256.New, secretKey)
	mac.Write(expiredJSON)
	sig := mac.Sum(nil)
	expiredLicense := base64.RawURLEncoding.EncodeToString(expiredJSON) + "." + base64.RawURLEncoding.EncodeToString(sig)
	expiredLicense = formatKey(expiredLicense)

	valid, msg = validateLicense("Alice", expiredLicense)
	fmt.Printf("â° è¿‡æœŸæ³¨å†Œç éªŒè¯: %v | ä¿¡æ¯: %s\n", valid, msg)
}
```

---

## ğŸ” è¾“å‡ºç¤ºä¾‹

```text
ç”¨æˆ·å: Alice
ç¡¬ä»¶ID: a1b2c3d4
æ³¨å†Œç :
eyJ1c2VyIjoiQWxpY2UiLCJleHBpcmVzIjoxNzQwNDAwMDAwLCJod2lkIjoiYTEyYmMzZDQifQ==.a1b2c3d4e5f6... 
ï¼ˆæ ¼å¼åŒ–åæ¯4ä½åˆ†éš”ï¼‰

âœ… éªŒè¯ç»“æœ: true | ä¿¡æ¯: éªŒè¯æˆåŠŸ
âŒ Bob éªŒè¯: false | ä¿¡æ¯: ç”¨æˆ·åä¸åŒ¹é…
âŒ ä¸åŒè®¾å¤‡éªŒè¯: false | ä¿¡æ¯: ç¡¬ä»¶ä¸åŒ¹é…ï¼ˆéæˆæƒè®¾å¤‡ï¼‰
â° è¿‡æœŸæ³¨å†Œç éªŒè¯: false | ä¿¡æ¯: æ³¨å†Œç å·²è¿‡æœŸ
```

---

## ğŸ›¡ï¸ å®‰å…¨æ€§è¯´æ˜

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| âœ… é˜²ç¯¡æ”¹ | ä½¿ç”¨ HMAC ç­¾åï¼Œä»»ä½•ä¿®æ”¹éƒ½ä¼šå¯¼è‡´éªŒè¯å¤±è´¥ |
| âœ… é˜²å¤ç”¨ | ç»‘å®šç”¨æˆ·å + ç¡¬ä»¶IDï¼Œä¸èƒ½è·¨è®¾å¤‡ä½¿ç”¨ |
| âœ… é˜²é•¿æœŸä½¿ç”¨ | æ”¯æŒè¿‡æœŸæ—¶é—´ï¼Œé€‚åˆè¯•ç”¨ç‰ˆæˆ–è®¢é˜…åˆ¶ |
| âš ï¸ å¯†é’¥å®‰å…¨ | `secretKey` å¿…é¡»åªåœ¨æœåŠ¡ç«¯ä¿å­˜ï¼Œ**ä¸å¯æ³„éœ²åˆ°å®¢æˆ·ç«¯** |
| âš ï¸ ç¡¬ä»¶IDè·å– | å®é™…é¡¹ç›®ä¸­åº”é€šè¿‡ç³»ç»Ÿ API è·å–çœŸå® MAC æˆ–ç¡¬ç›˜åºåˆ—å·ï¼ˆè·¨å¹³å°éœ€é€‚é…ï¼‰ |

---

## ğŸš€ è¿›ä¸€æ­¥å¢å¼ºå»ºè®®

1. **åœ¨çº¿æ¿€æ´»æœåŠ¡å™¨**ï¼šæ³¨å†Œç ç”±æœåŠ¡å™¨ç”Ÿæˆï¼Œå®¢æˆ·ç«¯ä»…æäº¤ä¿¡æ¯æ¿€æ´»ã€‚
2. **è®¸å¯è¯æ–‡ä»¶**ï¼šå°†æ³¨å†Œç ä¿å­˜ä¸º `.lic` æ–‡ä»¶ï¼Œé¿å…æ‰‹åŠ¨è¾“å…¥ã€‚
3. **åŠ å¯†æ•°æ®**ï¼šä½¿ç”¨ AES åŠ å¯† `LicenseData`ï¼Œå†ç­¾åï¼Œé˜²æ­¢ä¿¡æ¯æ³„éœ²ã€‚
4. **åŠé”€æœºåˆ¶**ï¼šæœåŠ¡å™¨ç»´æŠ¤é»‘åå•ï¼Œæ‹’ç»å·²æ’¤é”€çš„æ³¨å†Œç ã€‚
5. **åè°ƒè¯•/åé€†å‘**ï¼šåœ¨å®¢æˆ·ç«¯å¢åŠ ä¿æŠ¤ï¼Œé˜²æ­¢è¢«ç ´è§£ã€‚

---

å¦‚æœä½ éœ€è¦æˆ‘æä¾›ï¼š
- è·¨å¹³å°è·å–çœŸå® MAC åœ°å€çš„ä»£ç 
- ä½¿ç”¨ AES åŠ å¯† + HMAC ç­¾åçš„ç‰ˆæœ¬
- ä¸€ä¸ªç®€å•çš„ Web æ¿€æ´»æœåŠ¡å™¨ï¼ˆGo + Ginï¼‰

æ¬¢è¿ç»§ç»­æé—®ï¼æˆ‘å¯ä»¥å¸®ä½ æ­å»ºä¸€ä¸ªå®Œæ•´çš„æˆæƒç³»ç»Ÿã€‚

# è·¨å¹³å°è·å–çœŸå® MAC åœ°å€çš„ä»£ç 

ä¸‹é¢æ˜¯ä¸€ä¸ª **Go è¯­è¨€å®ç°çš„è·¨å¹³å°è·å–çœŸå® MAC åœ°å€** çš„ä»£ç ï¼Œæ”¯æŒï¼š

âœ… Windows  
âœ… macOS  
âœ… Linux  
âœ… FreeBSD ç­‰ç±» Unix ç³»ç»Ÿ  

> ğŸ’¡ è¯¥ä»£ç é€šè¿‡æ ‡å‡†åº“ `net.Interfaces()` è·å–ç½‘ç»œæ¥å£ä¿¡æ¯ï¼Œå¹¶æ™ºèƒ½è¿‡æ»¤æ— æ•ˆæˆ–è™šæ‹Ÿæ¥å£ï¼Œæå–**ç¬¬ä¸€ä¸ªæœ‰æ•ˆçš„ç‰©ç†ç½‘å¡ MAC åœ°å€**ã€‚

---

## âœ… ç‰¹æ€§è¯´æ˜

- ä½¿ç”¨ Go æ ‡å‡†åº“ï¼Œæ— éœ€å¤–éƒ¨ä¾èµ–
- è¿‡æ»¤å¸¸è§è™šæ‹Ÿ/å›ç¯/éš§é“æ¥å£ï¼ˆå¦‚ `lo`, `docker`, `vbox`, `vmnet`, `tun`, `tap`ï¼‰
- è¿”å› **è§„èŒƒåŒ–çš„å°å†™ MAC å­—ç¬¦ä¸²**ï¼ˆå¦‚ `a1b2c3d4e5f6` æˆ– `aa:bb:cc:dd:ee:ff`ï¼‰
- å¯ç”¨äºç”Ÿæˆç¡¬ä»¶æŒ‡çº¹ï¼ˆHWIDï¼‰

---

## ğŸ“¦ å®Œæ•´ Go ä»£ç ï¼ˆè·¨å¹³å°ï¼‰

```go
package main

import (
	"fmt"
	"net"
	"regexp"
	"strings"
)

// å¸¸è§çš„è™šæ‹Ÿ/æ— æ•ˆæ¥å£åç§°å‰ç¼€ï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰
var virtualInterfaces = []string{
	"lo",           // loopback
	"docker",       // Docker
	"veth",         // Docker è™šæ‹Ÿæ¥å£
	"br-",          // ç½‘æ¡¥
	"tun",          // TUN/TAP
	"tap",          // TUN/TAP
	"vmnet",        // macOS è™šæ‹Ÿæœº
	"vbox",         // VirtualBox
	"virbr",        // libvirt
	"ppp",          // ç‚¹å¯¹ç‚¹è¿æ¥
}

// æ£€æŸ¥æ¥å£åæ˜¯å¦ä¸ºè™šæ‹Ÿæ¥å£
func isVirtualInterface(name string) bool {
	name = strings.ToLower(name)
	for _, prefix := range virtualInterfaces {
		if strings.HasPrefix(name, prefix) {
			return true
		}
	}
	return false
}

// æ£€æŸ¥ MAC æ˜¯å¦æœ‰æ•ˆï¼ˆéç©ºã€éé›¶ã€éå¤šæ’­ï¼‰
func isValidMAC(mac net.HardwareAddr) bool {
	if len(mac) == 0 {
		return false
	}
	// å¤šæ’­åœ°å€ï¼šç¬¬ä¸€ä½ä¸ºå¥‡æ•°ï¼ˆå¦‚ 01:xx:xx...ï¼‰
	if mac[0]&0x01 == 1 {
		return false
	}
	// å…¨0åœ°å€ï¼ˆæœªåˆ†é…ï¼‰
	for _, b := range mac {
		if b != 0 {
			return true
		}
	}
	return false
}

// è·å–ç¬¬ä¸€ä¸ªæœ‰æ•ˆçš„ç‰©ç†ç½‘å¡ MAC åœ°å€ï¼ˆè¿”å›æ ¼å¼ï¼ša1b2c3d4e5f6ï¼‰
func getMACAddress() (string, error) {
	interfaces, err := net.Interfaces()
	if err != nil {
		return "", err
	}

	// æ­£åˆ™åŒ¹é…ä»¥å¤ªç½‘ç±»å‹
	ethernetRegex := regexp.MustCompile(`^en|eth|Ethernet`)

	for _, iface := range interfaces {
		// è·³è¿‡ï¼šæœªå¯ç”¨ã€è™šæ‹Ÿæ¥å£
		if (iface.Flags&net.FlagUp) == 0 {
			continue // æ¥å£æœªå¯ç”¨
		}
		if isVirtualInterface(iface.Name) {
			continue
		}

		// å¯é€‰ï¼šåªè€ƒè™‘ä»¥å¤ªç½‘æ¥å£ï¼ˆWi-Fi ä¹Ÿå¯è€ƒè™‘ï¼Œè§†éœ€æ±‚ï¼‰
		if !ethernetRegex.MatchString(iface.Name) && !strings.HasPrefix(iface.Name, "wlan") {
			continue
		}

		mac := iface.HardwareAddr
		if isValidMAC(mac) {
			// è¿”å›æ— åˆ†éš”ç¬¦çš„å°å†™ MAC
			return strings.ReplaceAll(strings.ToLower(mac.String()), ":", ""), nil
		}
	}

	// å¦‚æœæ²¡æ‰¾åˆ°ï¼Œé€€è€Œæ±‚å…¶æ¬¡ï¼šéå†æ‰€æœ‰æ¥å£æ‰¾ç¬¬ä¸€ä¸ªæœ‰æ•ˆ MAC
	for _, iface := range interfaces {
		if (iface.Flags&net.FlagUp) == 0 {
			continue
		}
		mac := iface.HardwareAddr
		if isValidMAC(mac) {
			return strings.ReplaceAll(strings.ToLower(mac.String()), ":", ""), nil
		}
	}

	return "", fmt.Errorf("æœªæ‰¾åˆ°æœ‰æ•ˆçš„ç‰©ç†ç½‘å¡ MAC åœ°å€")
}

// ä¸»å‡½æ•°æµ‹è¯•
func main() {
	mac, err := getMACAddress()
	if err != nil {
		fmt.Printf("âŒ è·å– MAC å¤±è´¥: %v\n", err)
		return
	}
	fmt.Printf("âœ… è·å–åˆ°çš„ MAC åœ°å€: %s\n", mac)
}
```

---

## ğŸ” è¾“å‡ºç¤ºä¾‹

```text
âœ… è·å–åˆ°çš„ MAC åœ°å€: a1b2c3d4e5f6
```

---

## ğŸ› ï¸ ä½¿ç”¨å»ºè®®

### 1. **ç”¨äºç¡¬ä»¶ç»‘å®šï¼ˆHWIDï¼‰**
ä½ å¯ä»¥å°† MAC åœ°å€å“ˆå¸ŒåŒ–ï¼Œé¿å…ç›´æ¥æš´éœ²ï¼š

```go
import "crypto/sha256"

func getHardwareID() string {
	mac, err := getMACAddress()
	if err != nil {
		return "unknown"
	}
	hash := sha256.Sum256([]byte(mac))
	return fmt.Sprintf("%x", hash[:8]) // å–å‰8å­—èŠ‚ä½œä¸º HWID
}
```

è¿™æ ·ç”Ÿæˆçš„ HWID æ›´å®‰å…¨ï¼š`a1b2c3d4` â†’ `e984a7b1`

---

### 2. **ç»„åˆæ›´å¤šç¡¬ä»¶ä¿¡æ¯ï¼ˆæ›´å¼ºç»‘å®šï¼‰**

å¯æ‰©å±•ä¸ºç»„åˆå¤šä¸ªç¡¬ä»¶æ ‡è¯†ï¼š

- ä¸»æ¿åºåˆ—å·ï¼ˆéœ€ç³»ç»Ÿå‘½ä»¤ï¼‰
- ç¡¬ç›˜åºåˆ—å·
- CPU IDï¼ˆè¾ƒéš¾è·å–ï¼Œè·¨å¹³å°å¤æ‚ï¼‰
- æœºå™¨å + MAC + OS ç±»å‹

ä¾‹å¦‚ï¼š
```go
hwid := fmt.Sprintf("%s_%s_%s", getMACAddress(), getHostname(), runtime.GOOS)
```

---

## âš ï¸ æ³¨æ„äº‹é¡¹

| é—®é¢˜ | è¯´æ˜ |
|------|------|
| ğŸŸ¡ **è™šæ‹Ÿæœº/äº‘æœåŠ¡å™¨** | å¯èƒ½æœ‰å¤šä¸ªç½‘å¡æˆ–éšæœº MACï¼Œå»ºè®®ç»‘å®šé¦–æ¬¡æ¿€æ´»çš„ MAC |
| ğŸŸ¡ **æ— çº¿ç½‘å¡ï¼ˆWi-Fiï¼‰** | æœ‰äº›è®¾å¤‡æ²¡æœ‰æœ‰çº¿ç½‘å¡ï¼Œåº”åŒ…å« `wlan` æ¥å£ |
| ğŸŸ¡ **MAC åœ°å€å¯æ›´æ”¹** | é«˜çº§ç”¨æˆ·å¯ä¼ªé€  MACï¼Œä»…ç”¨äºè½»é‡çº§ç»‘å®š |
| ğŸŸ¢ **ä¸å¯ç”¨äºå®‰å…¨æ•æ„Ÿåœºæ™¯** | å¦‚é‡‘èçº§æˆæƒï¼Œéœ€ç»“åˆæœåŠ¡å™¨éªŒè¯ |

---

## ğŸ§© å¯é€‰ï¼šè·å–ä¸»æœºåï¼ˆè¾…åŠ©ä¿¡æ¯ï¼‰

```go
import "os"

func getHostname() string {
	hostname, _ := os.Hostname()
	return hostname
}
```

---

## âœ… æ€»ç»“

è¿™ä¸ª `getMACAddress()` å‡½æ•°ï¼š
- è·¨å¹³å°ï¼ˆWindows/macOS/Linuxï¼‰
- å®‰å…¨è¿‡æ»¤è™šæ‹Ÿç½‘å¡
- è¿”å›å¯ç”¨äºæ³¨å†Œç ç»‘å®šçš„ç¡¬ä»¶æŒ‡çº¹
- å¯ç›´æ¥é›†æˆåˆ°ä¹‹å‰çš„ **å¸¦è¿‡æœŸå’Œç¡¬ä»¶ç»‘å®šçš„æ³¨å†Œç³»ç»Ÿ** ä¸­

---

å¦‚æœä½ éœ€è¦ï¼š
- è·å–ç¡¬ç›˜åºåˆ—å·ï¼ˆWindows: WMI, Linux: `/dev/sda` ä¿¡æ¯ï¼‰
- è·å–ä¸»æ¿åºåˆ—å·
- ç¼–è¯‘ä¸ºé™æ€äºŒè¿›åˆ¶ï¼ˆå¦‚ Linux ARMï¼‰
- æ‰“åŒ…æˆ SDK ä¾›å¤šä¸ªé¡¹ç›®ä½¿ç”¨

æ¬¢è¿ç»§ç»­æé—®ï¼æˆ‘å¯ä»¥å¸®ä½ æ„å»ºä¸€ä¸ªå®Œæ•´çš„ **è½¯ä»¶æˆæƒ SDK**ã€‚

#ã€€è·å–ç¡¬ç›˜åºåˆ—å·ã€è·å–ä¸»æ¿åºåˆ—å·

åœ¨è½¯ä»¶æˆæƒç³»ç»Ÿä¸­ï¼Œä¸ºäº†å®ç°æ›´å¼ºçš„**ç¡¬ä»¶ç»‘å®šï¼ˆHWIDï¼‰**ï¼Œé™¤äº† MAC åœ°å€å¤–ï¼Œè¿˜å¯ä»¥ç»“åˆ **ç¡¬ç›˜åºåˆ—å·** å’Œ **ä¸»æ¿åºåˆ—å·**ã€‚ä½†ç”±äºè¿™äº›ä¿¡æ¯æ¶‰åŠç³»ç»Ÿåº•å±‚ï¼Œä¸åŒæ“ä½œç³»ç»Ÿï¼ˆWindows / Linux / macOSï¼‰è·å–æ–¹å¼ä¸åŒï¼Œä¸”é€šå¸¸éœ€è¦è°ƒç”¨ç³»ç»Ÿå‘½ä»¤æˆ–ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ã€‚

ä¸‹é¢æˆ‘å°†ä¸ºä½ æä¾›ä¸€ä¸ª **è·¨å¹³å°ï¼ˆWindowsã€Linuxã€macOSï¼‰çš„ Go å®ç°**ï¼Œç”¨äºè·å–ï¼š

âœ… ç¡¬ç›˜åºåˆ—å·ï¼ˆä¸»ç¡¬ç›˜ï¼‰  
âœ… ä¸»æ¿åºåˆ—å·  
âœ… å¹¶å°è£…ä¸ºç»Ÿä¸€æ¥å£ï¼Œå¯ç”¨äºæ³¨å†Œç ç»‘å®š

---

## ğŸ§© æ”¯æŒå¹³å°

| å¹³å°    | ç¡¬ç›˜åºåˆ—å· | ä¸»æ¿åºåˆ—å· |
|---------|------------|------------|
| Windows | âœ… WMI æŸ¥è¯¢ | âœ… WMI æŸ¥è¯¢ |
| Linux   | âœ… `udevadm` æˆ– `lsblk` | âœ… `/sys` æ–‡ä»¶ç³»ç»Ÿ |
| macOS   | âœ… `system_profiler` | âœ… `system_profiler` |

---

## ğŸ“¦ å®Œæ•´ Go å®ç°ï¼ˆè·¨å¹³å°ï¼‰

```go
package main

import (
	"fmt"
	"os/exec"
	"runtime"
	"strings"
	"regexp"
)

// getDiskSerial è·å–ä¸»ç¡¬ç›˜åºåˆ—å·
func getDiskSerial() (string, error) {
	switch runtime.GOOS {
	case "windows":
		cmd := exec.Command("wmic", "diskdrive", "get", "serialnumber")
		output, err := cmd.Output()
		if err != nil {
			return "", err
		}
		lines := strings.Split(strings.TrimSpace(string(output)), "\n")
		for _, line := range lines {
			trimmed := strings.TrimSpace(line)
			if trimmed != "" && !strings.HasPrefix(strings.ToLower(line), "serialnumber") {
				return cleanSerial(trimmed), nil
			}
		}

	case "linux":
		// ä½¿ç”¨ lsblk è·å–æ ¹åˆ†åŒºæ‰€åœ¨ç£ç›˜ï¼Œå†æŸ¥ /dev/disk/by-id
		cmd := exec.Command("lsblk", "-no", "PKNAME", "/")
		output, err := cmd.Output()
		if err != nil {
			return "", err
		}
		diskName := strings.TrimSpace(string(output))
		if diskName == "" {
			return "", fmt.Errorf("æ— æ³•è·å–æ ¹ç£ç›˜åç§°")
		}

		idPath := "/dev/disk/by-id/ata-*" + diskName
		cmd = exec.Command("bash", "-c", fmt.Sprintf("ls %s 2>/dev/null | grep -v part | head -1", idPath))
		output, err = cmd.Output()
		if err != nil {
			return "", fmt.Errorf("æ— æ³•åˆ—å‡º by-id è·¯å¾„")
		}

		// æå–åºåˆ—å·éƒ¨åˆ†ï¼šata-WDC_WD10EZEX-00WN4A0_WD123456 -> WD123456
		fullPath := strings.TrimSpace(string(output))
		parts := strings.Split(fullPath, "-")
		if len(parts) > 0 {
			serial := parts[len(parts)-1]
			return cleanSerial(serial), nil
		}

	case "darwin": // macOS
		cmd := exec.Command("system_profiler", "SPSerialATADataType")
		output, err := cmd.Output()
		if err != nil {
			return "", err
		}

		// æŸ¥æ‰¾ "Medium ID:" æˆ– "Serial Number:"
		lines := strings.Split(string(output), "\n")
		for _, line := range lines {
			if strings.Contains(line, "Serial Number:") {
				parts := strings.Split(line, ":")
				if len(parts) > 1 {
					return cleanSerial(strings.TrimSpace(parts[1])), nil
				}
			}
		}
		return "", fmt.Errorf("æœªæ‰¾åˆ°ç¡¬ç›˜åºåˆ—å·")

	default:
		return "", fmt.Errorf("ä¸æ”¯æŒçš„æ“ä½œç³»ç»Ÿ: %s", runtime.GOOS)
	}

	return "", fmt.Errorf("æœªè·å–åˆ°ç¡¬ç›˜åºåˆ—å·")
}

// getMotherboardSerial è·å–ä¸»æ¿åºåˆ—å·
func getMotherboardSerial() (string, error) {
	switch runtime.GOOS {
	case "windows":
		cmd := exec.Command("wmic", "baseboard", "get", "serialnumber")
		output, err := cmd.Output()
		if err != nil {
			return "", err
		}
		lines := strings.Split(strings.TrimSpace(string(output)), "\n")
		for _, line := range lines {
			trimmed := strings.TrimSpace(line)
			if trimmed != "" && !strings.HasPrefix(strings.ToLower(line), "serialnumber") {
				return cleanSerial(trimmed), nil
			}
		}

	case "linux":
		// å°è¯•ä» /sys è·å–
		cmd := exec.Command("cat", "/sys/class/dmi/id/board_serial")
		output, err := cmd.Output()
		if err != nil {
			return "", fmt.Errorf("æ— æ³•è¯»å– /sys/class/dmi/id/board_serial")
		}
		serial := strings.TrimSpace(string(output))
		if serial != "" && serial != "None" && serial != "Not Specified" {
			return cleanSerial(serial), nil
		}

	case "darwin": // macOS
		cmd := exec.Command("system_profiler", "SPHardwareDataType")
		output, err := cmd.Output()
		if err != nil {
			return "", err
		}

		lines := strings.Split(string(output), "\n")
		for _, line := range lines {
			if strings.Contains(line, "Serial Number (system):") {
				parts := strings.Split(line, ":")
				if len(parts) > 1 {
					return cleanSerial(strings.TrimSpace(parts[1])), nil
				}
			}
		}
		return "", fmt.Errorf("æœªæ‰¾åˆ°ä¸»æ¿åºåˆ—å·")

	default:
		return "", fmt.Errorf("ä¸æ”¯æŒçš„æ“ä½œç³»ç»Ÿ: %s", runtime.GOOS)
	}

	return "", fmt.Errorf("æœªè·å–åˆ°ä¸»æ¿åºåˆ—å·")
}

// æ¸…ç†åºåˆ—å·ï¼šç§»é™¤ç©ºæ ¼ã€ç‰¹æ®Šå­—ç¬¦ï¼Œè½¬ä¸ºå¤§å†™ï¼ˆæˆ–å°å†™ï¼‰ï¼Œé¿å…ç©ºå€¼
func cleanSerial(s string) string {
	// ç§»é™¤ä¸å¯è§å­—ç¬¦å’Œå¤šä½™ç©ºæ ¼
	s = strings.TrimSpace(s)
	s = regexp.MustCompile(`[^a-zA-Z0-9]`).ReplaceAllString(s, "")
	if s == "" || strings.EqualFold(s, "none") || strings.EqualFold(s, "notspecified") {
		return "UNKNOWN"
	}
	return strings.ToUpper(s) // ç»Ÿä¸€æ ¼å¼
}

// ç”Ÿæˆç¡¬ä»¶æŒ‡çº¹ HWID = SHA256(MAC + Disk + Motherboard)
func getHardwareID() string {
	mac, _ := getMACAddress()
	if mac == "" {
		mac = "nomac"
	}

	disk, err := getDiskSerial()
	if err != nil {
		disk = "nodisk"
	}
	board, err := getMotherboardSerial()
	if err != nil {
		board = "noboard"
	}

	// ç»„åˆæ‰€æœ‰ç¡¬ä»¶ä¿¡æ¯
	raw := mac + ":" + disk + ":" + board

	// ä½¿ç”¨ SHA256 å“ˆå¸Œï¼Œå–å‰16ä½ä½œä¸º HWID
	hasher := sha256.New()
	hasher.Write([]byte(raw))
	hash := fmt.Sprintf("%x", hasher.Sum(nil))

	return strings.ToUpper(hash[:16]) // ç¤ºä¾‹ï¼šA1B2C3D4E5F67890
}

// --- å‰é¢å®šä¹‰çš„ getMACAddress() ---
// ï¼ˆè¯·å°†ä¹‹å‰å®ç°çš„ getMACAddress() å‡½æ•°å¤åˆ¶åˆ°è¿™é‡Œï¼‰
// ä¸ºèŠ‚çœç¯‡å¹…ï¼Œæ­¤å¤„çœç•¥ï¼Œä½ å¯å°†ä¸Šä¸€èŠ‚çš„å‡½æ•°ç²˜è´´è¿›æ¥

// --- å¼•å…¥ sha256 ---
import "crypto/sha256"

// --- ä¸»å‡½æ•°æµ‹è¯• ---
func main() {
	fmt.Println("æ“ä½œç³»ç»Ÿ:", runtime.GOOS)

	if mac, err := getMACAddress(); err == nil {
		fmt.Println("MAC åœ°å€:", mac)
	} else {
		fmt.Println("MAC åœ°å€:", "è·å–å¤±è´¥:", err)
	}

	if disk, err := getDiskSerial(); err == nil {
		fmt.Println("ç¡¬ç›˜åºåˆ—å·:", disk)
	} else {
		fmt.Println("ç¡¬ç›˜åºåˆ—å·:", "è·å–å¤±è´¥:", err)
	}

	if board, err := getMotherboardSerial(); err == nil {
		fmt.Println("ä¸»æ¿åºåˆ—å·:", board)
	} else {
		fmt.Println("ä¸»æ¿åºåˆ—å·:", "è·å–å¤±è´¥:", err)
	}

	fmt.Println("ç¡¬ä»¶æŒ‡çº¹ HWID:", getHardwareID())
}
```

---

## ğŸ” è¾“å‡ºç¤ºä¾‹ï¼ˆLinuxï¼‰

```text
æ“ä½œç³»ç»Ÿ: linux
MAC åœ°å€: a1b2c3d4e5f6
ç¡¬ç›˜åºåˆ—å·: WD1234567890
ä¸»æ¿åºåˆ—å·: MB987654321
ç¡¬ä»¶æŒ‡çº¹ HWID: A1B2C3D4E5F67890
```

---

## âš ï¸ æ³¨æ„äº‹é¡¹

| é—®é¢˜ | è§£å†³æ–¹æ¡ˆ |
|------|----------|
| âŒ Linux éœ€è¦ root æƒé™è¯» `/sys`ï¼Ÿ | å¤§å¤šæ•° `/sys/class/dmi/id/*` æ–‡ä»¶æ™®é€šç”¨æˆ·å¯è¯»ï¼Œå¦åˆ™éœ€ `sudo` |
| âŒ è™šæ‹Ÿæœºä¸­åºåˆ—å·ä¸º `None` | VMware/VirtualBox å¯é…ç½®æ˜¯å¦æš´éœ²ç‰©ç†åºåˆ—å· |
| âŒ Windows éœ€è¦ `wmic` | Windows 10+ é»˜è®¤è‡ªå¸¦ï¼ŒWindows 11 å¯èƒ½ç”¨ `PowerShell` æ›¿ä»£ï¼š<br>`Get-WmiObject win32_baseboard \| Select-Object SerialNumber` |
| âŒ macOS æƒé™ | `system_profiler` æ— éœ€ç‰¹æ®Šæƒé™ |

---

## âœ… å®‰å…¨å»ºè®®

- ä¸è¦ç›´æ¥æš´éœ²åŸå§‹ç¡¬ä»¶ä¿¡æ¯ï¼ˆå¦‚åºåˆ—å·ï¼‰ï¼Œä½¿ç”¨ **å“ˆå¸Œå HWID** ä½œä¸ºç»‘å®šæ ‡è¯†
- ç¬¬ä¸€æ¬¡æ¿€æ´»æ—¶è®°å½• HWIDï¼Œåç»­æ¯”å¯¹ï¼Œå…è®¸è½»å¾®å˜åŒ–ï¼ˆå¦‚æ›´æ¢ç½‘å¡ï¼‰
- å¯¹äºé«˜å®‰å…¨éœ€æ±‚ï¼Œåº”ç»“åˆ **åœ¨çº¿æ¿€æ´»æœåŠ¡å™¨** éªŒè¯

---

## ğŸš€ è¿›é˜¶å»ºè®®

| åŠŸèƒ½ | å®ç°æ–¹å¼ |
|------|----------|
| æ›¿ä»£ `wmic`ï¼ˆWindowsï¼‰ | ä½¿ç”¨ Go è°ƒç”¨ WMI COM æ¥å£ï¼ˆå¦‚ `go-ole` åº“ï¼‰ |
| æ›´å¼ºç¡¬ä»¶æŒ‡çº¹ | åŠ å…¥ CPU IDï¼ˆå¤æ‚ï¼‰ã€BIOS ç‰ˆæœ¬ã€æ˜¾å¡ä¿¡æ¯ |
| ç¦»çº¿ + åŠ å¯†å­˜å‚¨ | å°†æˆæƒä¿¡æ¯åŠ å¯†ä¿å­˜ä¸º `.lic` æ–‡ä»¶ |
| é˜²è™šæ‹Ÿæœº | æ£€æµ‹ `VBoxService`, `VMware`, `Hyper-V` è¿›ç¨‹æˆ–é©±åŠ¨ |

---

å¦‚æœä½ å¸Œæœ›æˆ‘ï¼š
- ä½¿ç”¨ `PowerShell` æ›¿ä»£ `wmic`ï¼ˆæ›´ç°ä»£ï¼‰
- ä½¿ç”¨ `go-ole` è°ƒç”¨ WMIï¼ˆæ— éœ€ shellï¼‰
- æ‰“åŒ…ä¸ºé™æ€åº“æˆ– CLI å·¥å…·
- å®ç°â€œé¦–æ¬¡æ¿€æ´»é”å®šè®¾å¤‡â€é€»è¾‘

æ¬¢è¿ç»§ç»­æé—®ï¼æˆ‘å¯ä»¥å¸®ä½ æ„å»ºä¸€ä¸ªå®Œæ•´çš„ **Go è½¯ä»¶æˆæƒ SDK**ã€‚

# æ›´å¼ºç¡¬ä»¶æŒ‡çº¹

ä¸ºäº†å®ç°**æ›´å¼ºçš„ç¡¬ä»¶æŒ‡çº¹ï¼ˆHardware Fingerprintï¼‰**ï¼Œé˜²æ­¢ç”¨æˆ·è½»æ˜“æ›´æ¢è®¾å¤‡æˆ–åœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œæˆæƒè½¯ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥ç»“åˆ **å¤šç§ç¡¬ä»¶æ ‡è¯†**ï¼Œå¹¶åŠ å…¥ **é˜²è™šæ‹Ÿæœºæ£€æµ‹ã€é˜²å…‹éš†æœºåˆ¶**ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ª **Go è¯­è¨€å®ç°çš„â€œå¼ºç¡¬ä»¶æŒ‡çº¹â€ç³»ç»Ÿ**ï¼Œå®ƒï¼š

âœ… èåˆå¤šä¸ªç¡¬ä»¶ç»´åº¦  
âœ… æ”¯æŒè·¨å¹³å°ï¼ˆWindows / Linux / macOSï¼‰  
âœ… æŠ—ä¼ªé€ ã€æŠ—è™šæ‹Ÿæœºã€æŠ—å…‹éš†  
âœ… è¾“å‡ºå”¯ä¸€ã€ç¨³å®šã€å®‰å…¨çš„ HWID  

---

## ğŸ” å¼ºç¡¬ä»¶æŒ‡çº¹ç»„æˆï¼ˆHWID = Hash ofï¼‰

| ç»„ä»¶ | è¯´æ˜ |
|------|------|
| 1. MAC åœ°å€ | ç½‘å¡ç‰©ç†åœ°å€ï¼ˆé¦–é€‰æœ‰çº¿ï¼‰ |
| 2. ç¡¬ç›˜åºåˆ—å· | ä¸»ç¡¬ç›˜å”¯ä¸€ ID |
| 3. ä¸»æ¿åºåˆ—å· | ä¸»æ¿å”¯ä¸€æ ‡è¯† |
| 4. BIOS ç‰ˆæœ¬/æ—¥æœŸ | é˜²æ­¢ç®€å•æ›¿æ¢ä¸»æ¿ |
| 5. CPU ID ç‰‡æ®µï¼ˆå¦‚ Vendor + ç‰¹å¾ï¼‰ | å¢åŠ  CPU å±‚çº§ç»‘å®š |
| 6. æœºå™¨åï¼ˆHostnameï¼‰ | ç”¨æˆ·ç¯å¢ƒè¾…åŠ©æ ‡è¯† |
| 7. æ“ä½œç³»ç»Ÿç±»å‹ + æ¶æ„ | é˜²è·¨å¹³å°æ»¥ç”¨ |
| âœ… è™šæ‹Ÿæœºæ£€æµ‹ | æ£€æµ‹æ˜¯å¦è¿è¡Œåœ¨ VM ä¸­ï¼ˆVBox / VMware / QEMU / Hyper-Vï¼‰ |

---

## ğŸ“¦ å®Œæ•´ Go å®ç°ï¼ˆå¢å¼ºç‰ˆ HWIDï¼‰

> âš ï¸ è¯´æ˜ï¼šCPU ID åœ¨ Go åŸç”Ÿåº“ä¸­ä¸å¯ç›´æ¥è·å–ï¼Œæˆ‘ä»¬é€šè¿‡ç³»ç»Ÿå‘½ä»¤é—´æ¥æå–ã€‚

```go
package main

import (
	"crypto/sha256"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strings"
	"regexp"
)

// clean æ¸…ç†å­—ç¬¦ä¸²ï¼šå»ç©ºæ ¼ã€ç‰¹æ®Šå­—ç¬¦ã€è½¬å¤§å†™
func clean(s string) string {
	s = strings.TrimSpace(s)
	s = regexp.MustCompile(`[^a-zA-Z0-9]`).ReplaceAllString(s, "")
	if s == "" || strings.EqualFold(s, "none") || strings.EqualFold(s, "notspecified") || strings.EqualFold(s, "null") {
		return "UNKNOWN"
	}
	return strings.ToUpper(s)
}

// getMACAddress è·å–æœ‰æ•ˆ MACï¼ˆè§å‰æ–‡ï¼Œæ­¤å¤„ç®€åŒ–è°ƒç”¨ï¼‰
func getMACAddress() string {
	interfaces, err := net.Interfaces()
	if err != nil {
		return "NOMAC"
	}
	for _, iface := range interfaces {
		if (iface.Flags&net.FlagUp) == 0 {
			continue
		}
		if len(iface.HardwareAddr) == 0 {
			continue
		}
		// è¿‡æ»¤ loopbackã€dockerã€veth ç­‰
		name := strings.ToLower(iface.Name)
		if strings.HasPrefix(name, "lo") || strings.Contains(name, "docker") || strings.HasPrefix(name, "veth") {
			continue
		}
		return clean(iface.HardwareAddr.String())
	}
	return "NOMAC"
}

// getDiskSerial è·å–ç¡¬ç›˜åºåˆ—å·ï¼ˆè§å‰æ–‡ï¼‰
func getDiskSerial() string {
	switch runtime.GOOS {
	case "windows":
		out, _ := exec.Command("wmic", "diskdrive", "get", "serialnumber").Output()
		for _, line := range strings.Split(string(out), "\n") {
			trimmed := strings.TrimSpace(line)
			if !strings.HasPrefix(strings.ToLower(line), "serialnumber") && trimmed != "" {
				return clean(trimmed)
			}
		}
	case "darwin":
		out, _ := exec.Command("system_profiler", "SPSerialATADataType").Output()
		for _, line := range strings.Split(string(out), "\n") {
			if strings.Contains(line, "Serial Number:") {
				parts := strings.Split(line, ":")
				return clean(strings.TrimSpace(parts[1]))
			}
		}
	case "linux":
		out, _ := exec.Command("lsblk", "-no", "PKNAME", "/").Output()
		disk := strings.TrimSpace(string(out))
		if disk != "" {
			idOut, _ := exec.Command("ls", fmt.Sprintf("/dev/disk/by-id/ata-*%s", disk)).Output()
			for _, path := range strings.Split(string(idOut), "\n") {
				p := strings.TrimSpace(path)
				if p != "" && !strings.Contains(p, "part") {
					parts := strings.Split(p, "-")
					if len(parts) > 0 {
						return clean(parts[len(parts)-1])
					}
				}
			}
		}
	}
	return "NODISK"
}

// getMotherboardSerial ä¸»æ¿åºåˆ—å·
func getMotherboardSerial() string {
	switch runtime.GOOS {
	case "windows":
		out, _ := exec.Command("wmic", "baseboard", "get", "serialnumber").Output()
		for _, line := range strings.Split(string(out), "\n") {
			trimmed := strings.TrimSpace(line)
			if !strings.HasPrefix(strings.ToLower(line), "serialnumber") && trimmed != "" {
				return clean(trimmed)
			}
		}
	case "linux":
		if data, err := os.ReadFile("/sys/class/dmi/id/board_serial"); err == nil {
			return clean(string(data))
		}
	case "darwin":
		out, _ := exec.Command("system_profiler", "SPHardwareDataType").Output()
		for _, line := range strings.Split(string(out), "\n") {
			if strings.Contains(line, "Serial Number (system):") {
				parts := strings.Split(line, ":")
				return clean(strings.TrimSpace(parts[1]))
			}
		}
	}
	return "NOBOARD"
}

// getBIOSVersion BIOS ç‰ˆæœ¬æˆ–é‡Šæ”¾æ—¥æœŸ
func getBIOSVersion() string {
	switch runtime.GOOS {
	case "windows":
		out, _ := exec.Command("wmic", "bios", "get", "releasedate,version").Output()
		return clean(string(out))
	case "linux":
		if data, err := os.ReadFile("/sys/class/dmi/id/bios_version"); err == nil {
			return clean(string(data))
		}
	case "darwin":
		out, _ := exec.Command("system_profiler", "SPHardwareDataType").Output()
		for _, line := range strings.Split(string(out), "\n") {
			if strings.Contains(line, "Boot ROM Version:") {
				parts := strings.Split(line, ":")
				return clean(strings.TrimSpace(parts[1]))
			}
		}
	}
	return "NOBIOS"
}

// getCPUInfo CPU å‚å•†æˆ–å‹å·ç‰‡æ®µ
func getCPUInfo() string {
	switch runtime.GOOS {
	case "windows":
		out, _ := exec.Command("wmic", "cpu", "get", "name").Output()
		for _, line := range strings.Split(string(out), "\n") {
			trimmed := strings.TrimSpace(line)
			if !strings.HasPrefix(strings.ToLower(line), "name") && trimmed != "" {
				return clean(regexp.MustCompile(`Intel|AMD`).FindString(trimmed))
			}
		}
	case "linux":
		if data, err := os.ReadFile("/proc/cpuinfo"); err == nil {
			for _, line := range strings.Split(string(data), "\n") {
				if strings.HasPrefix(line, "vendor_id") {
					return clean(strings.Split(line, ":")[1])
				}
			}
		}
	case "darwin":
		out, _ := exec.Command("sysctl", "-n", "machdep.cpu.brand_string").Output()
		return clean(regexp.MustCompile(`Intel|AMD`).FindString(string(out)))
	}
	return "NOCPU"
}

// getHostname ä¸»æœºå
func getHostname() string {
	hostname, _ := os.Hostname()
	return clean(hostname)
}

// isVirtualMachine æ£€æµ‹æ˜¯å¦è¿è¡Œåœ¨è™šæ‹Ÿæœºä¸­
func isVirtualMachine() bool {
	switch runtime.GOOS {
	case "windows":
		out, _ := exec.Command("wmic", "computersystem", "get", "manufacturer,model").Output()
		lower := strings.ToLower(string(out))
		vmKeywords := []string{"virtual", "vmware", "vbox", "qemu", "xen", "hyper-v", "parallels"}
		for _, kw := range vmKeywords {
			if strings.Contains(lower, kw) {
				return true
			}
		}
	case "linux":
		out, _ := exec.Command("dmesg").Output()
		lower := strings.ToLower(string(out))
		for _, kw := range []string{"vbox", "vmware", "qemu", "kvm", "xen"} {
			if strings.Contains(lower, kw) {
				return true
			}
		}
		// æ£€æŸ¥ systemd-detect-virt
		if out, err := exec.Command("systemd-detect-virt").Output(); err == nil {
			return strings.TrimSpace(string(out)) != "none"
		}
	case "darwin":
		// macOS ä¸Šä¸€èˆ¬ä¸æ˜¯ VMï¼Œä½†ä¹Ÿå¯æ£€æµ‹
		out, _ := exec.Command("sysctl", "-n", "kern.vm_guest").Output()
		guest := strings.TrimSpace(string(out))
		return guest != "" && guest != "none"
	}
	return false
}

// getHardwareID ç”Ÿæˆå¼ºç¡¬ä»¶æŒ‡çº¹
func getHardwareID() string {
	data := map[string]string{
		"mac":       getMACAddress(),
		"disk":      getDiskSerial(),
		"board":     getMotherboardSerial(),
		"bios":      getBIOSVersion(),
		"cpu":       getCPUInfo(),
		"hostname":  getHostname(),
		"os":        runtime.GOOS,
		"arch":      runtime.GOARCH,
		"is_vm":     fmt.Sprintf("%v", isVirtualMachine()),
	}

	// æ‹¼æ¥æ‰€æœ‰å­—æ®µ
	var parts []string
	for k, v := range data {
		parts = append(parts, k+"="+v)
	}
	combined := strings.Join(parts, "|")

	// SHA256 å“ˆå¸Œï¼Œè¾“å‡º 64 ä½åå…­è¿›åˆ¶
	hasher := sha256.New()
	hasher.Write([]byte(combined))
	hwid := fmt.Sprintf("%x", hasher.Sum(nil))

	// è¿”å›å‰16ä½ä½œä¸ºç®€æ´ HWIDï¼ˆæˆ–è¿”å›å®Œæ•´64ä½ï¼‰
	return strings.ToUpper(hwid[:16]) // ç¤ºä¾‹ï¼šA1B2C3D4E5F67890
}

// --- ä¸»å‡½æ•°æµ‹è¯• ---
func main() {
	fmt.Printf("æ“ä½œç³»ç»Ÿ: %s\n", runtime.GOOS)
	fmt.Printf("æ¶æ„: %s\n", runtime.GOARCH)
	fmt.Printf("MAC: %s\n", getMACAddress())
	fmt.Printf("ç¡¬ç›˜: %s\n", getDiskSerial())
	fmt.Printf("ä¸»æ¿: %s\n", getMotherboardSerial())
	fmt.Printf("BIOS: %s\n", getBIOSVersion())
	fmt.Printf("CPU: %s\n", getCPUInfo())
	fmt.Printf("ä¸»æœºå: %s\n", getHostname())
	fmt.Printf("æ˜¯å¦è™šæ‹Ÿæœº: %v\n", isVirtualMachine())

	fmt.Printf("\nğŸ” å¼ºç¡¬ä»¶æŒ‡çº¹ HWID: %s\n", getHardwareID())
}
```

---

## ğŸ§ª è¾“å‡ºç¤ºä¾‹

```text
æ“ä½œç³»ç»Ÿ: windows
æ¶æ„: amd64
MAC: A1B2C3D4E5F6
ç¡¬ç›˜: WD1234567890
ä¸»æ¿: MB987654321
BIOS: 20230510
CPU: INTEL
ä¸»æœºå: USERPC
æ˜¯å¦è™šæ‹Ÿæœº: false

ğŸ” å¼ºç¡¬ä»¶æŒ‡çº¹ HWID: A1B2C3D4E5F67890
```

---

## âœ… ä¼˜åŠ¿åˆ†æ

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **é«˜å”¯ä¸€æ€§** | å¤šå­—æ®µç»„åˆï¼Œæéš¾é‡å¤ |
| **ç¨³å®šæ€§** | æ­£å¸¸ä½¿ç”¨ä¸­ä¸ä¼šé¢‘ç¹å˜åŒ– |
| **é˜²è™šæ‹Ÿæœº** | è‡ªåŠ¨æ£€æµ‹å¹¶æ ‡è®° VMï¼Œå¯ç”¨äºæ‹’ç»æˆæƒ |
| **é˜²ç¯¡æ”¹** | åŸå§‹æ•°æ®è¢«å“ˆå¸Œï¼Œæ— æ³•åå‘ä¼ªé€  |
| **è·¨å¹³å°** | æ”¯æŒä¸‰å¤§ä¸»æµç³»ç»Ÿ |

---

## ğŸ›¡ï¸ å®‰å…¨å»ºè®®

1. **é¦–æ¬¡æ¿€æ´»é”å®š HWID**ï¼šè®°å½•ç”¨æˆ·é¦–æ¬¡æ¿€æ´»çš„ HWIDï¼Œåç»­å˜æ›´è¶…è¿‡é˜ˆå€¼åˆ™è¦æ±‚é‡æ–°éªŒè¯ã€‚
2. **å…è®¸è½»å¾®å˜åŒ–**ï¼šå¦‚æ›´æ¢ç½‘å¡ä½†å…¶ä»–ä¸€è‡´ï¼Œå¯è§†ä¸ºåŒä¸€è®¾å¤‡ã€‚
3. **æœåŠ¡å™¨ç«¯éªŒè¯**ï¼šå°† HWID ä¸ŠæŠ¥åˆ°æˆæƒæœåŠ¡å™¨ï¼Œå®ç°â€œä¸€æœºä¸€ç â€æˆ–â€œæœ€å¤šæ¿€æ´»3å°â€ã€‚
4. **å®šæœŸåˆ·æ–°æŒ‡çº¹**ï¼šé˜²æ­¢ç”¨æˆ·ä¸­é€”æ›´æ¢ç¡¬ä»¶ã€‚

---

## ğŸš€ è¿›é˜¶æ–¹å‘

| åŠŸèƒ½ | å®ç°æ–¹å¼ |
|------|----------|
| æ›´å¼º CPU ID | ä½¿ç”¨æ±‡ç¼– `cpuid` æŒ‡ä»¤ï¼ˆéœ€ CGOï¼‰ |
| æ˜¾å¡ä¿¡æ¯ | `nvidia-smi`, `dxdiag`, `system_profiler SPDisplaysDataType` |
| å†…å­˜å¤§å° | é˜²ä½é…è™šæ‹Ÿæœº |
| UEFI/Secure Boot çŠ¶æ€ | å¢åŠ å®‰å…¨å±‚çº§ |
| ç¡¬ä»¶æŒ‡çº¹æ¼‚ç§»æ£€æµ‹ | æœºå™¨å­¦ä¹ åˆ¤æ–­æ˜¯å¦â€œåŒä¸€ç”¨æˆ·â€ |

---

å¦‚æœä½ å¸Œæœ›æˆ‘ï¼š
- ä½¿ç”¨ CGO è·å–çœŸå® CPU ID
- å®ç°â€œæœ€å¤šæ¿€æ´» 3 å°è®¾å¤‡â€çš„æˆæƒé€»è¾‘
- æä¾› Web API æ¥å£ç”¨äºåœ¨çº¿æ¿€æ´»
- æ‰“åŒ…ä¸º `.so` / `.dll` ä¾›å…¶ä»–è¯­è¨€è°ƒç”¨

æ¬¢è¿ç»§ç»­æé—®ï¼æˆ‘å¯ä»¥å¸®ä½ æ‰“é€ ä¸€ä¸ª**ä¼ä¸šçº§è½¯ä»¶æˆæƒç³»ç»Ÿ**ã€‚

# ä½¿ç”¨ è®¸å¯è¯æ–‡ä»¶ï¼ˆJSON + ç­¾åï¼‰ æ›¿ä»£çº¯æ³¨å†Œç 

éå¸¸å¥½ï¼ä½¿ç”¨ **è®¸å¯è¯æ–‡ä»¶ï¼ˆLicense Fileï¼‰** æ›¿ä»£çº¯æ³¨å†Œç ï¼Œæ˜¯ç°ä»£è½¯ä»¶æˆæƒç³»ç»Ÿçš„ä¸»æµåšæ³•ã€‚å®ƒæ¯”â€œè¾“å…¥ä¸€ä¸²æ³¨å†Œç â€æ›´å®‰å…¨ã€æ›´çµæ´»ï¼Œèƒ½æºå¸¦ä¸°å¯Œçš„æˆæƒä¿¡æ¯ï¼ˆå¦‚ç”¨æˆ·ã€æœ‰æ•ˆæœŸã€åŠŸèƒ½æƒé™ã€ç¡¬ä»¶ç»‘å®šç­‰ï¼‰ï¼Œå¹¶é€šè¿‡**æ•°å­—ç­¾å**é˜²ç¯¡æ”¹ã€‚

---

## âœ… æœ¬æ–¹æ¡ˆç‰¹æ€§

- ä½¿ç”¨ **JSON æ ¼å¼** å­˜å‚¨è®¸å¯è¯æ•°æ®
- ä½¿ç”¨ **HMAC-SHA256** æˆ– **RSA ç­¾å** é˜²ç¯¡æ”¹ï¼ˆæœ¬æ–‡å…ˆç”¨ HMACï¼Œåé™„ RSA æ‰©å±•ï¼‰
- ç”Ÿæˆ `.lic` æ–‡ä»¶ï¼ˆå¦‚ `license.lic`ï¼‰
- å®¢æˆ·ç«¯éªŒè¯ç­¾å + è¿‡æœŸæ—¶é—´ + ç¡¬ä»¶ç»‘å®š
- å¯æ‰©å±•æ”¯æŒåŠŸèƒ½å¼€å…³ã€è®¢é˜…ç­‰çº§ç­‰

---

## ğŸ“¦ ç›®å½•ç»“æ„ï¼ˆç¤ºä¾‹ï¼‰

```
license.lic        â† ç”Ÿæˆçš„è®¸å¯è¯æ–‡ä»¶
main.go            â† ç¨‹åº
```

---

## ğŸ” å¯†é’¥ç®¡ç†

- `secretKey`ï¼šHMAC å¯†é’¥ï¼ˆæœåŠ¡ç«¯ä¸“ç”¨ï¼Œä¸å¯æ³„éœ²ï¼‰
- ç”Ÿäº§ç¯å¢ƒå»ºè®®ä½¿ç”¨ **RSA éå¯¹ç§°ç­¾å**ï¼ˆè§æ–‡æœ«æ‰©å±•ï¼‰

---

## ğŸ§© è®¸å¯è¯æ•°æ®ç»“æ„

```go
type License struct {
	User      string    `json:"user"`       // ç”¨æˆ·å
	Email     string    `json:"email"`      // é‚®ç®±ï¼ˆå¯é€‰ï¼‰
	Expires   int64     `json:"expires"`    // è¿‡æœŸæ—¶é—´ï¼ˆUnix ç§’ï¼‰
	HWID      string    `json:"hwid"`       // ç¡¬ä»¶æŒ‡çº¹ï¼ˆå¯é€‰ç»‘å®šï¼‰
	Features  []string  `json:"features"`   // åŠŸèƒ½æƒé™ï¼Œå¦‚ ["pro", "cloud"]
	IssuedAt  int64     `json:"issued_at"`  // ç­¾å‘æ—¶é—´
}
```

---

## âœ… å®Œæ•´ Go å®ç°ï¼ˆHMAC ç‰ˆï¼‰

```go
package main

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"time"
)

// æœåŠ¡ç«¯å¯†é’¥ï¼ˆå¿…é¡»ä¿å¯†ï¼ï¼‰
var secretKey = []byte("your-super-secret-license-key-2024")

// ç¡¬ä»¶æŒ‡çº¹ï¼ˆä½¿ç”¨å‰æ–‡å¼º HWIDï¼Œæ­¤å¤„ç®€åŒ–ï¼‰
func getHardwareID() string {
	return "A1B2C3D4E5F67890" // æ›¿æ¢ä¸ºçœŸå®å‡½æ•°
}

// License è®¸å¯è¯ç»“æ„
type License struct {
	User      string   `json:"user"`
	Email     string   `json:"email,omitempty"`
	Expires   int64    `json:"expires"`     // Unix æ—¶é—´æˆ³ï¼ˆç§’ï¼‰
	HWID      string   `json:"hwid,omitempty"` // ç»‘å®šè®¾å¤‡
	Features  []string `json:"features"`    // åŠŸèƒ½æƒé™
	IssuedAt  int64    `json:"issued_at"`
}

// generateLicenseFile ç”Ÿæˆå¸¦ç­¾åçš„è®¸å¯è¯æ–‡ä»¶
func generateLicenseFile(filename string, user, email string, days int, bindHWID bool) error {
	license := License{
		User:     user,
		Email:    email,
		Expires:  time.Now().AddDate(0, 0, days).Unix(),
		IssuedAt: time.Now().Unix(),
		Features: []string{"basic"},
	}
	if bindHWID {
		license.HWID = getHardwareID()
	}

	// 1. åºåˆ—åŒ–ä¸º JSON
	jsonData, err := json.Marshal(license)
	if err != nil {
		return err
	}

	// 2. è®¡ç®— HMAC ç­¾å
	mac := hmac.New(sha256.New, secretKey)
	mac.Write(jsonData)
	signature := mac.Sum(nil)

	// 3. æ‹¼æ¥ï¼šbase64(json).base64(signature)
	encodedData := base64.RawURLEncoding.EncodeToString(jsonData)
	encodedSig := base64.RawURLEncoding.EncodeToString(signature)
	content := encodedData + "." + encodedSig

	// 4. å†™å…¥æ–‡ä»¶
	return os.WriteFile(filename, []byte(content), 0644)
}

// validateLicenseFile éªŒè¯è®¸å¯è¯æ–‡ä»¶
func validateLicenseFile(filename, user string) (bool, string, *License) {
	content, err := os.ReadFile(filename)
	if err != nil {
		return false, "æ–‡ä»¶è¯»å–å¤±è´¥: " + err.Error(), nil
	}

	parts := strings.Split(strings.TrimSpace(string(content)), ".")
	if len(parts) != 2 {
		return false, "æ— æ•ˆçš„è®¸å¯è¯æ ¼å¼", nil
	}

	// è§£ç 
	data, err := base64.RawURLEncoding.DecodeString(parts[0])
	if err != nil {
		return false, "JSON è§£ç å¤±è´¥", nil
	}
	sig, err := base64.RawURLEncoding.DecodeString(parts[1])
	if err != nil {
		return false, "ç­¾åè§£ç å¤±è´¥", nil
	}

	// éªŒè¯ç­¾å
	mac := hmac.New(sha256.New, secretKey)
	mac.Write(data)
	expectedSig := mac.Sum(nil)
	if !hmac.Equal(sig, expectedSig) {
		return false, "ç­¾åéªŒè¯å¤±è´¥ï¼ˆè¢«ç¯¡æ”¹æˆ–å¯†é’¥é”™è¯¯ï¼‰", nil
	}

	// è§£æ JSON
	var license License
	if err := json.Unmarshal(data, &license); err != nil {
		return false, "JSON è§£æå¤±è´¥", nil
	}

	// éªŒè¯ç”¨æˆ·
	if license.User != user {
		return false, "ç”¨æˆ·åä¸åŒ¹é…", &license
	}

	// æ£€æŸ¥è¿‡æœŸ
	if time.Now().Unix() > license.Expires {
		return false, "è®¸å¯è¯å·²è¿‡æœŸ", &license
	}

	// æ£€æŸ¥ç¡¬ä»¶ç»‘å®š
	if license.HWID != "" && license.HWID != getHardwareID() {
		return false, "ç¡¬ä»¶ä¸åŒ¹é…ï¼ˆéæˆæƒè®¾å¤‡ï¼‰", &license
	}

	return true, "éªŒè¯æˆåŠŸ", &license
}

// ä¸»å‡½æ•°æµ‹è¯•
func main() {
	const licenseFile = "license.lic"
	username := "Alice"
	email := "alice@example.com"

	// 1. ç”Ÿæˆè®¸å¯è¯ï¼ˆç»‘å®šç¡¬ä»¶ï¼Œ30å¤©æœ‰æ•ˆæœŸï¼‰
	fmt.Println("ğŸ”§ æ­£åœ¨ç”Ÿæˆè®¸å¯è¯...")
	err := generateLicenseFile(licenseFile, username, email, 30, true)
	if err != nil {
		fmt.Printf("âŒ ç”Ÿæˆå¤±è´¥: %v\n", err)
		return
	}
	fmt.Printf("âœ… è®¸å¯è¯å·²ç”Ÿæˆ: %s\n\n", licenseFile)

	// 2. éªŒè¯è®¸å¯è¯
	fmt.Println("ğŸ” æ­£åœ¨éªŒè¯è®¸å¯è¯...")
	valid, msg, license := validateLicenseFile(licenseFile, username)
	fmt.Printf("âœ… éªŒè¯ç»“æœ: %v\n", valid)
	fmt.Printf("ğŸ“ ä¿¡æ¯: %s\n", msg)
	if license != nil {
		fmt.Printf("ğŸ‘¤ ç”¨æˆ·: %s\n", license.User)
		fmt.Printf("ğŸ“§ é‚®ç®±: %s\n", license.Email)
		fmt.Printf("ğŸ“… ç­¾å‘æ—¶é—´: %s\n", time.Unix(license.IssuedAt, 0).Format("2006-01-02 15:04"))
		fmt.Printf("â° è¿‡æœŸæ—¶é—´: %s\n", time.Unix(license.Expires, 0).Format("2006-01-02 15:04"))
		fmt.Printf("âš™ï¸  åŠŸèƒ½: %v\n", license.Features)
		if license.HWID != "" {
			fmt.Printf("ğŸ–¥ï¸  ç»‘å®š HWID: %s\n", license.HWID)
		}
	}

	// 3. æµ‹è¯•é”™è¯¯ç”¨æˆ·
	fmt.Println("\nâš ï¸ æµ‹è¯• Bob ä½¿ç”¨ Alice çš„è®¸å¯è¯...")
	valid, msg, _ = validateLicenseFile(licenseFile, "Bob")
	fmt.Printf("Bob éªŒè¯: %v | %s\n", valid, msg)
}
```

---

## ğŸ“„ ç”Ÿæˆçš„ `license.lic` æ–‡ä»¶å†…å®¹ç¤ºä¾‹

```
eyJ1c2VyIjoiQWxpY2UiLCJlbWFpbCI6ImFsaWNlQGV4YW1wbGUuY29tIiwiZXhwaXJlcyI6MTc0MDQwMDAwMCwiaHdpZCI6IkExQjJDM0Q0RTVGNjc4OTAiLCJmZWF0dXJlcyI6WyJiYXNpYyJdLCJpc3N1ZWRfYXQiOjE3Mjc4MDAwMDB9.a1b2c3d4e5f6...
```

æ ¼å¼ï¼š`base64(json).base64(hmac)`

---

## âœ… ä¼˜åŠ¿å¯¹æ¯”

| ç‰¹æ€§ | çº¯æ³¨å†Œç  | è®¸å¯è¯æ–‡ä»¶ï¼ˆæœ¬æ–¹æ¡ˆï¼‰ |
|------|----------|------------------|
| æºå¸¦ä¿¡æ¯é‡ | å°‘ï¼ˆä»…å­—ç¬¦ä¸²ï¼‰ | å¤šï¼ˆJSON ç»“æ„åŒ–ï¼‰ |
| å¯è¯»æ€§ | ä½ | ä¸­ï¼ˆBase64 ç¼–ç ï¼‰ |
| å®‰å…¨æ€§ | ä¾èµ–ç®—æ³• | ç­¾åé˜²ç¯¡æ”¹ |
| æ‰©å±•æ€§ | å·® | å¥½ï¼ˆå¯åŠ å­—æ®µï¼‰ |
| ç”¨æˆ·ä½“éªŒ | éœ€æ‰‹åŠ¨è¾“å…¥ | è‡ªåŠ¨åŠ è½½æ–‡ä»¶ |
| æ”¯æŒç»‘å®š | æœ‰é™ | å¯ç»‘å®š HWIDã€æ—¶é—´ã€åŠŸèƒ½ |

---

## ğŸ” è¿›é˜¶ï¼šä½¿ç”¨ RSA éå¯¹ç§°ç­¾åï¼ˆæ›´å®‰å…¨ï¼‰

> ğŸ’¡ æ¨èç”¨äºç”Ÿäº§ç¯å¢ƒï¼šç§é’¥ç­¾åï¼ˆæœåŠ¡ç«¯ï¼‰ï¼Œå…¬é’¥éªŒè¯ï¼ˆå®¢æˆ·ç«¯ï¼‰

### ä¿®æ”¹ç‚¹ï¼š

```go
import "crypto/rsa"

// ä½¿ç”¨ rsa.SignPKCS1v15 + rsa.Verify
```

- æœåŠ¡ç«¯ç”¨ **ç§é’¥** ç­¾å
- å®¢æˆ·ç«¯åªå« **å…¬é’¥**ï¼Œæ— æ³•ä¼ªé€ 
- å³ä½¿é€†å‘ä¹Ÿæ— æ³•ç”Ÿæˆæ–°è®¸å¯è¯

> âœ… å®Œå…¨é˜²æ­¢å®¢æˆ·ç«¯è¢«ç”¨æ¥ç”Ÿæˆåˆæ³•è®¸å¯è¯

å¦‚æœä½ éœ€è¦æˆ‘æä¾› **RSA ç‰ˆæœ¬å®ç°**ï¼ˆå«å¯†é’¥ç”Ÿæˆã€ç­¾åã€éªŒè¯ï¼‰ï¼Œè¯·å‘Šè¯‰æˆ‘ï¼

---

## ğŸš€ åº”ç”¨åœºæ™¯å»ºè®®

| åœºæ™¯ | å»ºè®® |
|------|------|
| ä¸ªäººè½¯ä»¶ | HMAC + `.lic` æ–‡ä»¶è¶³å¤Ÿ |
| ä¼ä¸šè½¯ä»¶ | RSA ç­¾å + åœ¨çº¿æ¿€æ´» |
| SaaS æ¡Œé¢ç«¯ | `.lic` æ–‡ä»¶ + å®šæœŸè”ç½‘éªŒè¯ |
| é˜²ç ´è§£è¦æ±‚é«˜ | RSA + ä»£ç æ··æ·† + åè°ƒè¯• |

---

## âœ… æ€»ç»“

ä½ ç°åœ¨æ‹¥æœ‰äº†ä¸€ä¸ªå®Œæ•´çš„ï¼š
> **åŸºäº JSON + HMAC ç­¾åçš„è®¸å¯è¯æ–‡ä»¶ç³»ç»Ÿ**

å®ƒå¯ä»¥ï¼š
- ç”Ÿæˆå®‰å…¨çš„ `.lic` æ–‡ä»¶
- éªŒè¯ç”¨æˆ·ã€æ—¶é—´ã€ç¡¬ä»¶
- æ”¯æŒåŠŸèƒ½æƒé™æ§åˆ¶
- æ˜“äºæ‰©å±•ä¸ºåœ¨çº¿æˆæƒç³»ç»Ÿ

---

å¦‚æœä½ å¸Œæœ›æˆ‘ç»§ç»­å®ç°ï¼š

- âœ… RSA éå¯¹ç§°ç­¾åç‰ˆæœ¬
- âœ… è®¸å¯è¯åŠé”€åˆ—è¡¨ï¼ˆCRLï¼‰
- âœ… åœ¨çº¿æ¿€æ´»æœåŠ¡å™¨ï¼ˆGo + Ginï¼‰
- âœ… GUI å¯¼å…¥è®¸å¯è¯å¯¹è¯æ¡†ï¼ˆFyne / Wailsï¼‰

æ¬¢è¿ç»§ç»­æé—®ï¼æˆ‘å¯ä»¥å¸®ä½ æ‰“é€ ä¸€ä¸ª**å·¥ä¸šçº§è½¯ä»¶æˆæƒä½“ç³»**ã€‚

# RSA éå¯¹ç§°ç­¾åç‰ˆæœ¬

å¤ªå¥½äº†ï¼ä¸‹é¢æ˜¯ä½¿ç”¨ **RSA éå¯¹ç§°ç­¾å** å®ç°çš„ **è®¸å¯è¯æ–‡ä»¶ç³»ç»Ÿï¼ˆJSON + RSA ç­¾åï¼‰** çš„å®Œæ•´ Go å®ç°ã€‚

---

## ğŸ” ä¸ºä»€ä¹ˆç”¨ RSAï¼Ÿ

| ä¼˜åŠ¿ | è¯´æ˜ |
|------|------|
| âœ… å®‰å…¨æ€§é«˜ | ç§é’¥ç­¾åï¼ˆæœåŠ¡ç«¯ï¼‰ï¼Œå…¬é’¥éªŒè¯ï¼ˆå®¢æˆ·ç«¯ï¼‰ï¼Œ**å®¢æˆ·ç«¯æ— æ³•ä¼ªé€ è®¸å¯è¯** |
| âœ… é˜²é€†å‘ç ´è§£ | å³ä½¿åç¼–è¯‘è½¯ä»¶ï¼Œä¹Ÿæ— æ³•ç”Ÿæˆåˆæ³•è®¸å¯è¯ |
| âœ… ç”Ÿäº§çº§æ ‡å‡† | Adobeã€Microsoft ç­‰å•†ä¸šè½¯ä»¶å¹¿æ³›ä½¿ç”¨ |

---

## ğŸ“¦ åŠŸèƒ½ç‰¹æ€§

- ä½¿ç”¨ **RSA 2048** ç­¾å
- è®¸å¯è¯æ ¼å¼ï¼š`base64(json).base64(signature)`
- æ”¯æŒï¼šç”¨æˆ·åã€é‚®ç®±ã€è¿‡æœŸæ—¶é—´ã€ç¡¬ä»¶ç»‘å®šã€åŠŸèƒ½æƒé™
- æœåŠ¡ç«¯ç”Ÿæˆå¹¶ç­¾å
- å®¢æˆ·ç«¯ä»…ç”¨å…¬é’¥éªŒè¯

---

## ğŸ—‚ï¸ æ–‡ä»¶ç»“æ„

```
private.pem     â† ç§é’¥ï¼ˆæœåŠ¡ç«¯ä¿å­˜ï¼Œç»ä¸æ³„éœ²ï¼‰
public.pem      â† å…¬é’¥ï¼ˆå¯åµŒå…¥å®¢æˆ·ç«¯ï¼‰
license.lic     â† ç”Ÿæˆçš„è®¸å¯è¯æ–‡ä»¶
main.go         â† ç¨‹åº
```

---

## ğŸ”§ ç¬¬ä¸€æ­¥ï¼šç”Ÿæˆ RSA å¯†é’¥å¯¹ï¼ˆå‘½ä»¤è¡Œï¼‰

```bash
# ç”Ÿæˆç§é’¥ï¼ˆPKCS#1ï¼‰
openssl genrsa -out private.pem 2048

# æå–å…¬é’¥ï¼ˆPKIX/PKCS#8ï¼‰
openssl rsa -in private.pem -pubout -out public.pem
```

> âš ï¸ `private.pem` å¿…é¡»ä¸¥æ ¼ä¿å¯†ï¼ä»…ç”¨äºæœåŠ¡ç«¯ç­¾å‘è®¸å¯è¯ã€‚

---

## âœ… å®Œæ•´ Go å®ç°ï¼ˆRSA ç‰ˆï¼‰

```go
package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"os"
	"time"
)

// License è®¸å¯è¯ç»“æ„
type License struct {
	User      string   `json:"user"`
	Email     string   `json:"email,omitempty"`
	Expires   int64    `json:"expires"`     // Unix æ—¶é—´æˆ³ï¼ˆç§’ï¼‰
	HWID      string   `json:"hwid,omitempty"` // ç»‘å®šè®¾å¤‡
	Features  []string `json:"features"`    // åŠŸèƒ½æƒé™
	IssuedAt  int64    `json:"issued_at"`
}

// è¯»å–ç§é’¥æ–‡ä»¶
func readPrivateKey(filename string) (*rsa.PrivateKey, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	block, _ := pem.Decode(data)
	if block == nil || block.Type != "RSA PRIVATE KEY" {
		return nil, fmt.Errorf("æ— æ³•è§£ç  PEM å—")
	}
	return x509.ParsePKCS1PrivateKey(block.Bytes)
}

// è¯»å–å…¬é’¥æ–‡ä»¶
func readPublicKey(filename string) (*rsa.PublicKey, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	block, _ := pem.Decode(data)
	if block == nil || block.Type != "PUBLIC KEY" {
		return nil, fmt.Errorf("æ— æ³•è§£ç  PEM å—")
	}
	pub, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		return nil, err
	}
	rsaPub, ok := pub.(*rsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("ä¸æ˜¯ RSA å…¬é’¥")
	}
	return rsaPub, nil
}

// signLicense ä½¿ç”¨ç§é’¥ç­¾åè®¸å¯è¯
func signLicense(privateKey *rsa.PrivateKey, license License) (string, error) {
	// 1. åºåˆ—åŒ–ä¸º JSON
	jsonData, err := json.Marshal(license)
	if err != nil {
		return "", err
	}

	// 2. è®¡ç®— SHA256
	hash := sha256.Sum256(jsonData)

	// 3. RSA ç­¾åï¼ˆPKCS#1 v1.5ï¼‰
	signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hash[:])
	if err != nil {
		return "", err
	}

	// 4. ç¼–ç ï¼šbase64(json).base64(signature)
	encodedData := base64.RawURLEncoding.EncodeToString(jsonData)
	encodedSig := base64.RawURLEncoding.EncodeToString(signature)
	return encodedData + "." + encodedSig, nil
}

// verifyLicense ä½¿ç”¨å…¬é’¥éªŒè¯è®¸å¯è¯
func verifyLicense(publicKey *rsa.PublicKey, content string, user string) (bool, string, *License) {
	parts := strings.Split(content, ".")
	if len(parts) != 2 {
		return false, "æ ¼å¼é”™è¯¯ï¼šç¼ºå°‘ç­¾å", nil
	}

	// è§£ç 
	data, err := base64.RawURLEncoding.DecodeString(parts[0])
	if err != nil {
		return false, "JSON è§£ç å¤±è´¥", nil
	}
	sig, err := base64.RawURLEncoding.DecodeString(parts[1])
	if err != nil {
		return false, "ç­¾åè§£ç å¤±è´¥", nil
	}

	// éªŒè¯ç­¾åå‰å…ˆç®—å“ˆå¸Œ
	hash := sha256.Sum256(data)
	err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hash[:], sig)
	if err != nil {
		return false, "ç­¾åéªŒè¯å¤±è´¥ï¼š" + err.Error(), nil
	}

	// è§£æè®¸å¯è¯å†…å®¹
	var license License
	if err := json.Unmarshal(data, &license); err != nil {
		return false, "JSON è§£æå¤±è´¥", nil
	}

	// éªŒè¯ä¸šåŠ¡é€»è¾‘
	if license.User != user {
		return false, "ç”¨æˆ·åä¸åŒ¹é…", &license
	}
	if time.Now().Unix() > license.Expires {
		return false, "è®¸å¯è¯å·²è¿‡æœŸ", &license
	}
	if license.HWID != "" && license.HWID != getHardwareID() {
		return false, "ç¡¬ä»¶ä¸åŒ¹é…", &license
	}

	return true, "éªŒè¯æˆåŠŸ", &license
}

// æ¨¡æ‹Ÿç¡¬ä»¶æŒ‡çº¹ï¼ˆæ›¿æ¢ä¸ºçœŸå®å‡½æ•°ï¼‰
func getHardwareID() string {
	return "A1B2C3D4E5F67890"
}

// ä¸»å‡½æ•°æµ‹è¯•
func main() {
	const (
		privateKeyFile = "private.pem"
		publicKeyFile  = "public.pem"
		licenseFile    = "license.lic"
	)
	username := "Alice"
	email := "alice@example.com"

	// 1. è¯»å–ç§é’¥ï¼ˆæœåŠ¡ç«¯ï¼‰
	fmt.Println("ğŸ” è¯»å–ç§é’¥...")
	privateKey, err := readPrivateKey(privateKeyFile)
	if err != nil {
		fmt.Printf("âŒ è¯»å–ç§é’¥å¤±è´¥: %v\n", err)
		fmt.Println("è¯·è¿è¡Œ: openssl genrsa -out private.pem 2048")
		return
	}

	// 2. åˆ›å»ºè®¸å¯è¯
	license := License{
		User:     username,
		Email:    email,
		Expires:  time.Now().AddDate(0, 0, 30).Unix(), // 30å¤©åè¿‡æœŸ
		IssuedAt: time.Now().Unix(),
		Features: []string{"pro", "cloud"},
		HWID:     getHardwareID(), // ç»‘å®šè®¾å¤‡
	}

	// 3. ç­¾åç”Ÿæˆè®¸å¯è¯æ–‡ä»¶
	fmt.Println("ğŸ“ æ­£åœ¨ç­¾åç”Ÿæˆè®¸å¯è¯...")
	signedContent, err := signLicense(privateKey, license)
	if err != nil {
		fmt.Printf("âŒ ç­¾åå¤±è´¥: %v\n", err)
		return
	}

	// å†™å…¥æ–‡ä»¶
	err = os.WriteFile(licenseFile, []byte(signedContent), 0644)
	if err != nil {
		fmt.Printf("âŒ å†™å…¥æ–‡ä»¶å¤±è´¥: %v\n", err)
		return
	}
	fmt.Printf("âœ… è®¸å¯è¯å·²ç”Ÿæˆ: %s\n\n", licenseFile)

	// 4. è¯»å–å…¬é’¥ï¼ˆå®¢æˆ·ç«¯ï¼‰
	fmt.Println("ğŸ” è¯»å–å…¬é’¥å¹¶éªŒè¯...")
	publicKey, err := readPublicKey(publicKeyFile)
	if err != nil {
		fmt.Printf("âŒ è¯»å–å…¬é’¥å¤±è´¥: %v\n", err)
		return
	}

	// è¯»å–å¹¶éªŒè¯è®¸å¯è¯
	content, err := os.ReadFile(licenseFile)
	if err != nil {
		fmt.Printf("âŒ è¯»å–è®¸å¯è¯å¤±è´¥: %v\n", err)
		return
	}

	valid, msg, lic := verifyLicense(publicKey, string(content), username)
	fmt.Printf("âœ… éªŒè¯ç»“æœ: %v\n", valid)
	fmt.Printf("ğŸ“ ä¿¡æ¯: %s\n", msg)
	if lic != nil {
		fmt.Printf("ğŸ‘¤ ç”¨æˆ·: %s\n", lic.User)
		fmt.Printf("ğŸ“§ é‚®ç®±: %s\n", lic.Email)
		fmt.Printf("ğŸ“… ç­¾å‘: %s\n", time.Unix(lic.IssuedAt, 0).Format("2006-01-02"))
		fmt.Printf("â° è¿‡æœŸ: %s\n", time.Unix(lic.Expires, 0).Format("2006-01-02"))
		fmt.Printf("âš™ï¸  åŠŸèƒ½: %v\n", lic.Features)
		if lic.HWID != "" {
			fmt.Printf("ğŸ–¥ï¸  ç»‘å®š HWID: %s\n", lic.HWID)
		}
	}

	// 5. æµ‹è¯•ç¯¡æ”¹ï¼ˆæ‰‹åŠ¨ä¿®æ”¹å†…å®¹ï¼‰
	fmt.Println("\nâš ï¸ æµ‹è¯•ç¯¡æ”¹è®¸å¯è¯...")
	tampered := string(content) + "x"
	valid, msg, _ = verifyLicense(publicKey, tampered, username)
	fmt.Printf("ç¯¡æ”¹åéªŒè¯: %v | %s\n", valid, msg)
}
```

---

## ğŸ“„ ç”Ÿæˆçš„ `license.lic` ç¤ºä¾‹

```
eyJ1c2VyIjoiQWxpY2UiLCJlbWFpbCI6ImFsaWNlQGV4YW1wbGUuY29tIiwiZXhwaXJlcyI6MTc0MDQwMDAwMCwiaHdpZCI6IkExQjJDM0Q0RTVGNjc4OTAiLCJmZWF0dXJlcyI6WyJwcm8iLCJjbG91ZCJdLCJpc3N1ZWRfYXQiOjE3Mjc4MDAwMDB9.ABC123defGHI456...
```

---

## âœ… å®‰å…¨æ€§è¯´æ˜

| é¡¹ç›® | è¯´æ˜ |
|------|------|
| ğŸ” ç§é’¥å®‰å…¨ | `private.pem` åªèƒ½åœ¨æœåŠ¡ç«¯ä½¿ç”¨ï¼Œç»ä¸æ‰“åŒ…è¿›å®¢æˆ·ç«¯ |
| ğŸ”“ å…¬é’¥åˆ†å‘ | `public.pem` å¯ç¡¬ç¼–ç è¿›å®¢æˆ·ç«¯æˆ–åŠ¨æ€åŠ è½½ |
| ğŸ›¡ï¸ é˜²ä¼ªé€  | æ²¡æœ‰ç§é’¥ï¼Œæ— æ³•ç”Ÿæˆæœ‰æ•ˆç­¾å |
| ğŸ§¯ é˜²ç¯¡æ”¹ | ä»»ä½•ä¿®æ”¹éƒ½ä¼šå¯¼è‡´ç­¾åéªŒè¯å¤±è´¥ |
| ğŸ“… é˜²é‡æ”¾ | æœ‰è¿‡æœŸæ—¶é—´ + ç­¾å‘æ—¶é—´æ§åˆ¶ |

---

## ğŸš€ ç”Ÿäº§ç¯å¢ƒå»ºè®®

| åœºæ™¯ | å»ºè®® |
|------|------|
| è‡ªåŠ¨åŒ–ç­¾å‘ | æ­å»º Web æœåŠ¡ï¼Œç”¨æˆ·ä»˜æ¬¾åè‡ªåŠ¨ç”Ÿæˆ `.lic` æ–‡ä»¶ |
| å…¬é’¥åµŒå…¥ | å°† `public.pem` ç¼–è¯‘è¿›äºŒè¿›åˆ¶ï¼ˆ`go:embed`ï¼‰ |
| åœ¨çº¿éªŒè¯ | å®¢æˆ·ç«¯å®šæœŸä¸ŠæŠ¥è®¸å¯è¯çŠ¶æ€ï¼Œæ”¯æŒåŠé”€ |
| å¤šè®¸å¯è¯ | æ”¯æŒ `license-dev.lic`, `license-prod.lic` |
| ç­¾åç®—æ³•å‡çº§ | å¯æ”¹ç”¨ `PSS` å¡«å……ï¼ˆæ›´å®‰å…¨ï¼‰ |

---

## ğŸ”„ æ‰©å±•ï¼šä½¿ç”¨ PSS ç­¾åï¼ˆæ›´å®‰å…¨ï¼‰

```go
// ç­¾å
rsa.SignPSS(rand.Reader, privateKey, crypto.SHA256, hash[:], &rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthAuto})

// éªŒè¯
rsa.VerifyPSS(publicKey, crypto.SHA256, hash[:], sig, nil)
```

PSS æ˜¯æ›´ç°ä»£çš„éšæœºåŒ–ç­¾åæ–¹æ¡ˆï¼Œæ¨èç”¨äºæ–°ç³»ç»Ÿã€‚

---

## âœ… æ€»ç»“

ä½ ç°åœ¨æ‹¥æœ‰äº†ä¸€ä¸ª **å·¥ä¸šçº§è½¯ä»¶æˆæƒç³»ç»Ÿçš„æ ¸å¿ƒç»„ä»¶**ï¼š

> âœ… åŸºäº RSA éå¯¹ç§°ç­¾å  
> âœ… å®‰å…¨ã€å¯æ‰©å±•ã€é˜²ç¯¡æ”¹  
> âœ… æ”¯æŒç»‘å®šç”¨æˆ·ã€æ—¶é—´ã€ç¡¬ä»¶ã€åŠŸèƒ½  

---

å¦‚æœä½ å¸Œæœ›æˆ‘ç»§ç»­å®ç°ï¼š

- âœ… ä½¿ç”¨ `go:embed` å°†å…¬é’¥åµŒå…¥äºŒè¿›åˆ¶
- âœ… æ­å»ºä¸€ä¸ªç®€å•çš„ **è®¸å¯è¯ç­¾å‘ Web æœåŠ¡ï¼ˆGin + HTML è¡¨å•ï¼‰**
- âœ… å®ç° **è®¸å¯è¯åŠé”€æœºåˆ¶ï¼ˆCRL æˆ–åœ¨çº¿æ£€æŸ¥ï¼‰**
- âœ… å®¢æˆ·ç«¯è‡ªåŠ¨æ£€æŸ¥æ›´æ–°è®¸å¯è¯

æ¬¢è¿ç»§ç»­æé—®ï¼æˆ‘ä»¬å¯ä»¥ä¸€æ­¥æ­¥æ‰“é€ ä¸€ä¸ªå®Œæ•´çš„ **è½¯ä»¶æˆæƒå¹³å°**ã€‚

# æ­å»ºä¸€ä¸ªç®€å•çš„ è®¸å¯è¯ç­¾å‘ Web æœåŠ¡

å¤ªå¥½äº†ï¼ä¸‹é¢æˆ‘ä»¬ç”¨ **Go + Gin** æ­å»ºä¸€ä¸ªç®€å•çš„ **è®¸å¯è¯ç­¾å‘ Web æœåŠ¡**ï¼Œå…·å¤‡ä»¥ä¸‹åŠŸèƒ½ï¼š

---

## âœ… åŠŸèƒ½æ¸…å•

- ğŸ–¥ï¸ Web ç®¡ç†ç•Œé¢ï¼ˆHTML è¡¨å•ï¼‰
- ğŸ“ å¡«å†™ç”¨æˆ·ä¿¡æ¯ç”Ÿæˆè®¸å¯è¯
- ğŸ” ä½¿ç”¨ **RSA ç§é’¥ç­¾å**
- ğŸ’¾ ç”Ÿæˆ `.lic` æ–‡ä»¶ä¾›ä¸‹è½½
- ğŸ“ æ”¯æŒä¸Šä¼ å…¬é’¥/ç§é’¥ï¼ˆå¯é€‰ï¼‰
- ğŸ›¡ï¸ ç®€å•è®¤è¯ï¼ˆé˜²æ­¢æœªæˆæƒè®¿é—®ï¼‰

---

## ğŸ—‚ï¸ é¡¹ç›®ç»“æ„

```
/license-server/
â”œâ”€â”€ main.go               // Gin æœåŠ¡
â”œâ”€â”€ templates/
â”‚   â””â”€â”€ form.html         // ç”Ÿæˆè¡¨å•é¡µé¢
â”œâ”€â”€ static/
â”‚   â””â”€â”€ style.css         // ç®€å•æ ·å¼
â”œâ”€â”€ keys/
â”‚   â”œâ”€â”€ private.pem       // ç§é’¥ï¼ˆå¿…é¡»å­˜åœ¨ï¼‰
â”‚   â””â”€â”€ public.pem        // å…¬é’¥ï¼ˆç”¨äºéªŒè¯ï¼‰
â”œâ”€â”€ licenses/             // ç”Ÿæˆçš„è®¸å¯è¯æ–‡ä»¶
â””â”€â”€ private.pem           // ï¼ˆä¹Ÿå¯æ”¾æ ¹ç›®å½•ï¼‰
```

---

## ğŸ§° ç¬¬ä¸€æ­¥ï¼šå®‰è£…ä¾èµ–

```bash
go mod init license-server
go get -u github.com/gin-gonic/gin
```

---

## ğŸ” ç¬¬äºŒæ­¥ï¼šå‡†å¤‡å¯†é’¥

ç¡®ä¿ä½ å·²ç”Ÿæˆ RSA å¯†é’¥å¯¹ï¼ˆå¦‚å‰æ‰€è¿°ï¼‰ï¼š

```bash
openssl genrsa -out keys/private.pem 2048
openssl rsa -in keys/private.pem -pubout -out keys/public.pem
```

> âš ï¸ `private.pem` å¿…é¡»ä¿å¯†ï¼Œä¸è¦æäº¤åˆ° Gitï¼

---

## ğŸ“„ `templates/form.html`

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>è®¸å¯è¯ç­¾å‘ç³»ç»Ÿ</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <div class="container">
    <h1>ğŸ” è®¸å¯è¯ç­¾å‘ç³»ç»Ÿ</h1>
    <form method="POST" action="/generate">
      <label>ç”¨æˆ·å:</label>
      <input type="text" name="user" required><br>

      <label>é‚®ç®±:</label>
      <input type="email" name="email"><br>

      <label>æœ‰æ•ˆæœŸï¼ˆå¤©ï¼‰:</label>
      <input type="number" name="days" value="30" min="1" max="365" required><br>

      <label>ç»‘å®šç¡¬ä»¶ï¼Ÿ</label>
      <input type="checkbox" name="bind_hwid" value="true"> æ˜¯<br>

      <label>åŠŸèƒ½æƒé™:</label>
      <input type="text" name="features" placeholder="pro,cloud" value="basic"><br>

      <button type="submit">ç”Ÿæˆè®¸å¯è¯</button>
    </form>

    {{if .Error}}
    <div class="error">âŒ {{.Error}}</div>
    {{end}}

    {{if .Filename}}
    <div class="success">
      âœ… è®¸å¯è¯å·²ç”Ÿæˆï¼
      <a href="/download/{{.Filename}}" class="download">ç‚¹å‡»ä¸‹è½½</a>
    </div>
    {{end}}
  </div>
</body>
</html>
```

---

## ğŸ¨ `static/style.css`

```css
body { font-family: Arial, sans-serif; background: #f4f4f4; }
.container { max-width: 500px; margin: 50px auto; padding: 20px; background: white; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
input[type="text"], input[type="email"], input[type="number"] { width: 100%; padding: 8px; margin: 5px 0 15px; border: 1px solid #ccc; border-radius: 4px; }
button { background: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; }
button:hover { background: #0056b3; }
.download { color: #007bff; text-decoration: none; }
.error { color: red; margin: 10px 0; }
.success { color: green; margin: 10px 0; }
```

---

## ğŸš€ `main.go` â€”â€” å®Œæ•´ Web æœåŠ¡

```go
package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

// License ç»“æ„
type License struct {
	User      string   `json:"user"`
	Email     string   `json:"email,omitempty"`
	Expires   int64    `json:"expires"`
	HWID      string   `json:"hwid,omitempty"`
	Features  []string `json:"features"`
	IssuedAt  int64    `json:"issued_at"`
}

// è¯»å–ç§é’¥
func readPrivateKey(path string) (*rsa.PrivateKey, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	block, _ := pem.Decode(data)
	if block == nil || block.Type != "RSA PRIVATE KEY" {
		return nil, fmt.Errorf("invalid PEM block")
	}
	return x509.ParsePKCS1PrivateKey(block.Bytes)
}

// ç­¾åç”Ÿæˆè®¸å¯è¯å†…å®¹
func signLicense(privateKey *rsa.PrivateKey, license License) (string, error) {
	jsonData, err := json.Marshal(license)
	if err != nil {
		return "", err
	}

	hash := sha256.Sum256(jsonData)
	signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hash[:])
	if err != nil {
		return "", err
	}

	encodedData := base64.RawURLEncoding.EncodeToString(jsonData)
	encodedSig := base64.RawURLEncoding.EncodeToString(signature)
	return encodedData + "." + encodedSig, nil
}

// æ¨¡æ‹Ÿ HWIDï¼ˆå®é™…ä¸­åº”ä»å®¢æˆ·ç«¯ä¸ŠæŠ¥ï¼‰
func getHardwareID() string {
	return "A1B2C3D4E5F67890" // å®é™…åº”ç”±å®¢æˆ·ç«¯æä¾›
}

func main() {
	// åˆ›å»ºå¿…è¦ç›®å½•
	os.MkdirAll("licenses", 0755)
	os.MkdirAll("keys", 0755)

	// åŠ è½½ç§é’¥
	privateKeyPath := "keys/private.pem"
	privateKey, err := readPrivateKey(privateKeyPath)
	if err != nil {
		fmt.Printf("âŒ æ— æ³•åŠ è½½ç§é’¥ %s: %v\n", privateKeyPath, err)
		fmt.Println("è¯·è¿è¡Œ: openssl genrsa -out keys/private.pem 2048")
		return
	}

	// Gin æ¨¡å¼ï¼ˆrelease æ¨¡å¼å…³é—­è°ƒè¯•ï¼‰
	gin.SetMode(gin.ReleaseMode)
	r := gin.Default()

	// é™æ€æ–‡ä»¶
	r.Static("/static", "static")
	r.LoadHTMLGlob("templates/*")

	// ä¸»é¡µ
	r.GET("/", func(c *gin.Context) {
		c.HTML(http.StatusOK, "form.html", nil)
	})

	// ç”Ÿæˆè®¸å¯è¯
	r.POST("/generate", func(c *gin.Context) {
		user := c.PostForm("user")
		email := c.PostForm("email")
		daysStr := c.PostForm("days")
		bindHwid := c.PostForm("bind_hwid") == "true"
		featuresStr := c.PostForm("features")

		if user == "" {
			c.HTML(http.StatusBadRequest, "form.html", gin.H{"Error": "ç”¨æˆ·åä¸èƒ½ä¸ºç©º"})
			return
		}

		days, err := strconv.Atoi(daysStr)
		if err != nil || days < 1 {
			days = 30
		}

		// è§£æåŠŸèƒ½æƒé™
		features := strings.Split(strings.TrimSpace(featuresStr), ",")
		for i := range features {
			features[i] = strings.TrimSpace(features[i])
		}

		// æ„å»ºè®¸å¯è¯
		license := License{
			User:     user,
			Email:    email,
			Expires:  time.Now().AddDate(0, 0, days).Unix(),
			IssuedAt: time.Now().Unix(),
			Features: features,
		}
		if bindHwid {
			license.HWID = getHardwareID()
		}

		// ç­¾å
		signedContent, err := signLicense(privateKey, license)
		if err != nil {
			c.HTML(http.StatusInternalServerError, "form.html", gin.H{"Error": "ç­¾åå¤±è´¥: " + err.Error()})
			return
		}

		// ä¿å­˜æ–‡ä»¶
		filename := fmt.Sprintf("license_%s.lic", user)
		filepath := filepath.Join("licenses", filename)
		if err := os.WriteFile(filepath, []byte(signedContent), 0644); err != nil {
			c.HTML(http.StatusInternalServerError, "form.html", gin.H{"Error": "ä¿å­˜æ–‡ä»¶å¤±è´¥"})
			return
		}

		// è¿”å›é¡µé¢
		c.HTML(http.StatusOK, "form.html", gin.H{
			"Filename": filename,
			"Success":  "è®¸å¯è¯ç”ŸæˆæˆåŠŸ",
		})
	})

	// ä¸‹è½½è®¸å¯è¯
	r.GET("/download/:filename", func(c *gin.Context) {
		filename := c.Param("filename")
		path := filepath.Join("licenses", filename)
		if _, err := os.Stat(path); os.IsNotExist(err) {
			c.String(http.StatusNotFound, "æ–‡ä»¶ä¸å­˜åœ¨")
			return
		}
		c.Header("Content-Disposition", "attachment; filename="+filename)
		c.Header("Content-Type", "application/octet-stream")
		c.File(path)
	})

	// å¯åŠ¨æœåŠ¡
	fmt.Println("âœ… è®¸å¯è¯ç­¾å‘æœåŠ¡å·²å¯åŠ¨ï¼šhttp://localhost:8080")
	fmt.Println("ğŸ”‘ è¯·ç¡®ä¿ keys/private.pem å­˜åœ¨ä¸”ä¿å¯†ï¼")
	if err := r.Run(":8080"); err != nil {
		fmt.Printf("âŒ æœåŠ¡å¯åŠ¨å¤±è´¥: %v\n", err)
	}
}
```

---

## â–¶ï¸ è¿è¡ŒæœåŠ¡

```bash
# 1. ç¡®ä¿ç›®å½•ç»“æ„æ­£ç¡®
mkdir -p templates static licenses keys

# 2. æ”¾å…¥ HTML å’Œ CSS
# ï¼ˆå°†ä¸Šé¢çš„ form.html å’Œ style.css æ”¾å…¥å¯¹åº”ç›®å½•ï¼‰

# 3. ç”Ÿæˆå¯†é’¥
openssl genrsa -out keys/private.pem 2048
openssl rsa -in keys/private.pem -pubout -out keys/public.pem

# 4. è¿è¡Œ
go run main.go
```

ç„¶åè®¿é—®ï¼š[http://localhost:8080](http://localhost:8080)

---

## ğŸ“¸ ç•Œé¢æ•ˆæœ

- è¡¨å•å¡«å†™ç”¨æˆ·ä¿¡æ¯
- ç‚¹å‡»â€œç”Ÿæˆè®¸å¯è¯â€
- ä¸‹è½½ `.lic` æ–‡ä»¶
- å¯ç”¨äºå®¢æˆ·ç«¯éªŒè¯ï¼ˆä½¿ç”¨ `public.pem`ï¼‰

---

## ğŸ” å®‰å…¨å¢å¼ºå»ºè®®

| åŠŸèƒ½ | å®ç°æ–¹å¼ |
|------|----------|
| ğŸ”’ ç™»å½•è®¤è¯ | æ·»åŠ ç”¨æˆ·åå¯†ç ä¸­é—´ä»¶ |
| ğŸ“Š æ—¥å¿—è®°å½• | è®°å½•æ¯æ¬¡ç­¾å‘è¡Œä¸º |
| ğŸš« é‡å¤ç­¾å‘é™åˆ¶ | æŒ‰ç”¨æˆ·é™åˆ¶é¢‘ç‡ |
| ğŸ§¹ è‡ªåŠ¨æ¸…ç† | å®šæœŸåˆ é™¤æ—§è®¸å¯è¯ |
| â˜ï¸ HTTPS | ä½¿ç”¨ Let's Encrypt æˆ–åå‘ä»£ç† |

---

## ğŸš€ ä¸‹ä¸€æ­¥å»ºè®®

ä½ å¯ä»¥ç»§ç»­æ‰©å±•ï¼š

- âœ… æ·»åŠ ç”¨æˆ·æ•°æ®åº“ï¼ˆSQLiteï¼‰
- âœ… æ”¯æŒåœ¨çº¿æ¿€æ´»ï¼ˆå®¢æˆ·ç«¯ä¸Šä¼  HWIDï¼ŒæœåŠ¡ç«¯è¿”å›è®¸å¯è¯ï¼‰
- âœ… å®ç°è®¸å¯è¯åŠé”€åˆ—è¡¨ï¼ˆCRLï¼‰
- âœ… æ”¯æŒè®¢é˜…ç»­æœŸ
- âœ… Docker éƒ¨ç½²

---

å¦‚æœä½ å¸Œæœ›æˆ‘å¸®ä½ å®ç°ï¼š

- âœ… ç”¨æˆ·ç™»å½•è®¤è¯ï¼ˆBasic Auth æˆ– JWTï¼‰
- âœ… æ•°æ®åº“å­˜å‚¨ç­¾å‘è®°å½•
- âœ… å®¢æˆ·ç«¯æ¿€æ´» API
- âœ… Dockerfile éƒ¨ç½²

æ¬¢è¿ç»§ç»­æé—®ï¼æˆ‘ä»¬å¯ä»¥ä¸€æ­¥æ­¥æ‰“é€ ä¸€ä¸ª **å®Œæ•´çš„è½¯ä»¶æˆæƒå¹³å°** ğŸ’¼ğŸ”

